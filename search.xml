<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JPA-Introduction]]></title>
      <url>%2F2017%2F07%2F29%2FJPA-Introduction%2F</url>
      <content type="text"><![CDATA[JPA是什么JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 JPA 是 sun 提出的一个对象持久化规范，各 JavaEE 应用服务器自主选择具体实现，JPA 的设计者是 Hibernate 框架的作者，因此Hibernate作为Jboss服务器中JPA的默认实现，Oracle的Weblogic使用EclipseLink(以前叫TopLink)作为默认的JPA实现，IBM的Websphere和Sun的Glassfish默认使用OpenJPA(Apache的一个开源项目)作为其默认的JPA实现。 JPA 的底层实现是一些流行的开源 ORM 框架，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过面向对象编程的思想操作关系型数据库的规范。 JPA架构JPA(Java持久性API)是存储业务实体关联的实体的来源。它显示了如何定义一个面向普通Java对象(POJO)作为一个实体，以及如何与管理关系实体。 下图显示了JPA的类的层次结构。它显示核心类和JPA接口。 单元 描述 EntityManagerFactory 这是一个EntityManager的工厂类。它创建并管理多个EntityManager实例。 EntityManager 这是一个接口，它管理的持久化操作的对象。它的工作原理类似工厂的查询实例。 Entity 实体是持久性对象是存储在数据库中的记录。 EntityTransaction 它与EntityManager是一对一的关系。对于每一个EntityManager，操作是由EntityTransaction类维护。 Persistence 这个类包含静态方法来获取EntityManagerFactory实例。 Query 该接口由每个JPA供应商实现，能够获得符合标准的关系对象。 An entity is a lightweight persistence domain object. Typically, an entity represents a table in a relational database, and each entity instance corresponds to a row in that table. The primary programming artifact of an entity is the entity class, although entities can use helper classes. The persistent state of an entity is represented through either persistent fields or persistent properties. These fields or properties use object/relational mapping annotations to map the entities and entity relationships to the relational data in the underlying data store. 简单来说，一个实体代表一个关系型数据库的一张表，而一个实体实例相应的代表那张表的一行记录 Managing Entities Entities are managed by the entity manager, which is represented by javax.persistence.EntityManager instances. Each EntityManager instance is associated with a persistence context: a set of managed entity instances that exist in a particular data store. A persistence context defines the scope under which particular entity instances are created, persisted, and removed. The EntityManager interface defines the methods that are used to interact with the persistence context. EntityManagerFactory和EntityManager的关系是1对多。这是一个工厂类EntityManager实例。 EntityManager和EntityTransaction之间的关系是1对1。对于每个EntityManager操作，只有一个EntityTransaction实例。 EntityManager和Query之间的关系是1对多。查询数众多可以使用一个EntityManager实例执行。 EntityManager实体之间的关系是1对多。一个EntityManager实例可以管理多个实体。 搭建JPA工程创建maven工程 创建一个空的maven工程，然后编写pom.xml文件，添加如下配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;properties&gt; &lt;hibernate.version&gt;4.1.9.Final&lt;/hibernate.version&gt; &lt;hibernate-jpa.version&gt;2.0-cr-1&lt;/hibernate-jpa.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.java-persistence&lt;/groupId&gt; &lt;artifactId&gt;jpa-api&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate-jpa.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 实体类 Person.java 1234567891011121314151617181920212223242526272829303132333435363738394041package com.janzenzhang.spring4.jpa.entity;/** * Created by 张 成 on 2017/7/16. */import javax.persistence.*;import javax.validation.constraints.Max;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import java.io.Serializable;@Entity@Tablepublic class Person implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy= GenerationType.AUTO) private Integer id; @Size(min = 1, max = 30) @NotNull private String name; @Min(1) @Max(200) @NotNull private Integer age; private Double salary; //省略掉set、get方法 @Override public String toString() &#123; return "Person [id=" + id + ", name=" + name + ", age=" + age + ",salary="+salary+"]"; &#125;&#125; persistence.xml 这个文件中，我们将注册数据库，并制定实体类。在src/main/resources/META-INF/目录中创建一个文件。由于程序会默认在classpath路径下寻找META-INF/persistence.xml，因此resources一定要标记为Resource Folder 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="2.0"&gt; &lt;persistence-unit name="defaultPersistenceUnit" transaction-type="RESOURCE_LOCAL"&gt; &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt; &lt;class&gt;com.janzenzhang.spring4.jpa.entity.Person&lt;/class&gt; &lt;properties&gt; &lt;!-- 使用MySQL方言 --&gt; &lt;property name="hibernate.dialect" value="org.hibernate.dialect.MySQL5Dialect"/&gt; &lt;!-- 数据库连接的URL地址 --&gt; &lt;property name="hibernate.connection.url" value="jdbc:mysql://localhost:3306/jpa"/&gt; &lt;!-- 数据库连接的驱动 --&gt; &lt;property name="hibernate.connection.driver_class" value="com.mysql.jdbc.Driver"/&gt; &lt;!-- 数据库连接的用户名 --&gt; &lt;property name="hibernate.connection.username" value="root"/&gt; &lt;!-- 数据库连接的密码 --&gt; &lt;property name="hibernate.connection.password" value="root"/&gt; &lt;!--数据库命名策略--&gt; &lt;property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/&gt; &lt;!-- 显示SQL语句 --&gt; &lt;property name="hibernate.show_sql" value="true"/&gt; &lt;!-- 在显示SQL语句时格式化语句 --&gt; &lt;property name="hibernate.format_sql" value="true"/&gt; &lt;!-- 自动输出schema创建DDL语句 --&gt; &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 持久化操作 1234567891011121314151617181920212223242526272829package com.janzenzhang.spring4.jpa.entity;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.Persistence;public class PersonTest &#123; public static void main(String[] args) &#123; EntityManagerFactory emfactory = Persistence. createEntityManagerFactory( &quot;defaultPersistenceUnit&quot; ); EntityManager entitymanager = emfactory. createEntityManager( ); entitymanager.getTransaction( ).begin( ); Person person=new Person(); person.setAge(18); person.setSalary(121d); person.setName(&quot;zhangsan&quot;); entitymanager.persist( person ); entitymanager.getTransaction( ).commit( ); entitymanager.close(); emfactory.close( ); &#125;&#125; 在上面的代码中 createEntityManagerFactory() 通过提供我们在 persistent.xml 文件提供持久化单元相同唯一的名称创建一个实体管理工厂。 EntityManagerFactory对象将使用createEntityManager()方法创建entitymanger实例。 EntityManager对象创建 开启 事务管理。通过使用 EntityManager 对象，我们可以持久化实体到数据库中 JPQL基于首次在EJB2.0中引入的EJB查询语言(EJB QL),Java持久化查询语言(JPQL)是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将SQL语法和简单查询语义绑定在一起·使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的SQL。 其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，而不是表名和表的属性 标准查询示例代码： 12345678910111213141516171819202122232425262728package com.janzenzhang.spring4.jpa.entity;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.Persistence;import javax.persistence.Query;import java.util.List;public class StandardQuery &#123; public static void main(String[] args) &#123; EntityManagerFactory emfactory = Persistence.createEntityManagerFactory("defaultPersistenceUnit"); EntityManager entityManager = emfactory.createEntityManager(); Query query = entityManager.createQuery("select p from Person p where p.salary between 100 and 200"); List&lt;Person&gt; list = query.getResultList(); for(Person e: list)&#123; System.out.println("Person ID: " + e.getId()); System.out.println("Person Salary: " + e.getSalary()); &#125; Query query1 = entityManager.createQuery("select MAX(p.salary) from Person p"); Double result = (Double) query1.getSingleResult(); System.out.println("Max Person Salary:" + result); &#125;&#125; 命名查询@NamedQuery注解被定义为一个预定义的查询字符串，它是不可改变的查询。相反，动态查询，命名查询可以通过POJO分离JPQL查询字符串提高代码的组织。它也传送的查询参数，而不是动态地嵌入文本到查询字符串，并因此产生更高效的查询。 首先，@NamedQuery注解添加到package com.janzenzhang.spring4.jpa.entity包中的 Person实体，类名为Person.java下，如下所示： 123456@Entity@NamedQuery(query = &quot;Select e from Person e where e.id = :id&quot;, name = &quot;find person by id&quot;)@Tablepublic class Person implements Serializable &#123;&#125; 使用方法： 123456789101112131415161718192021222324252627282930package com.janzenzhang.spring4.jpa.entity;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.Persistence;import javax.persistence.Query;import java.util.List;public class NamedQueries &#123; public static void main(String[] args) &#123; EntityManagerFactory emfactory = Persistence.createEntityManagerFactory("defaultPersistenceUnit"); EntityManager entityManager = emfactory.createEntityManager(); Query query = entityManager.createNamedQuery("find person by id"); query.setParameter("id", 1);// List&lt;Person&gt; list = query.getResultList();// for(Person e : list)&#123;// System.out.println("Person ID:" + e.getId());// System.out.println("Person Salary: "+ e.getSalary());// &#125; Person e = (Person) query.getSingleResult(); System.out.println("Person ID:" + e.getId()); System.out.println("Person Salary: "+ e.getSalary()); &#125;&#125; JPA高级映射继承是任何面向对象语言的核心理念，因此我们可以用实体之间的继承关系和策略。JPA支持三种类型的继承策略：SINGLE_TABLE，OINED_TABLE和TABLE_PER_CONCRETE_CLASS。 单表继承策略单表继承策略，父类实体和子类实体共用一张数据库表，在表中通过一列辨别字段来区别不同类别的实体。具体做法如下： a.在父类实体的 @Entity 注解下添加如下的注解： 123@Inheritance(Strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name=&quot;辨别字段列名&quot;) @DiscriminatorValue(父类实体辨别字段列值) b.在子类实体的 @Entity 注解下添加如下的注解： 1@DiscriminatorValue(子类实体辨别字段列值) Joined继承策略Joined 策略，父类实体和子类实体分别对应数据库中不同的表，子类实体的表中只存在其扩展的特殊属性，父类的公共属性保存在父类实体映射表中。 具体做法：只需在父类实体的 @Entity 注解下添加如下注解： 1@Inheritance(Strategy=InheritanceType.JOINED) 子类实体不需要特殊说明。 TABLE_PER_CLASS 策略：TABLE_PER_CLASS 策略，父类实体和子类实体每个类分别对应一张数据库中的表，子类表中保存所有属性，包括从父类实体中继承的属性。 具体做法：只需在父类实体的 @Entity 注解下添加如下注解： 1@Inheritance(Strategy=InheritanceType.TABLE_PER_CLASS) 子类实体不需要特殊说明。 举例让我们考虑一个例子。下图显示了三个等级，即Staff, TeachingStaff, and NonTeachingStaff和他们之间的关系。 在上面的图中，员工是一个实体，而TeachingStaff和NonTeachingStaff是工作人员的子实体。在这里，我们将使用上面的例子来演示继承的全部三个策略. 单一表策略会使用所有类的字段（包含父类和子类），并且把他们都映射到同一张表中。这里的鉴别值起着区分在一个表中三个实体的值的关键作用。 让我们考虑上面的例子。TeachingStaff和NonTeachingStaff是Staff的子类。按照继承的概念，一个子类继承其父类中的属性。因此sid和sname属于TeachingStaff和NonTeachingStaff 字段。创建JPA项目。在这个项目中的所有模块，如下所示： 创建实体 Staff.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.janzenzhang.spring4.jpa.entity;import java.io.Serializable;import javax.persistence.DiscriminatorColumn;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Inheritance;import javax.persistence.InheritanceType;import javax.persistence.Table;@Entity@Table@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name ="type")public class Staff implements Serializable&#123; @Id @GeneratedValue( strategy = GenerationType.AUTO ) private int sid; private String sname; public Staff( String sname ) &#123; this.sname = sname; &#125; public Staff( ) &#123; super( ); &#125; public int getSid( ) &#123; return sid; &#125; public void setSid( int sid ) &#123; this.sid = sid; &#125; public String getSname( ) &#123; return sname; &#125; public void setSname( String sname ) &#123; this.sname = sname; &#125;&#125; 在上面的代码@DescriminatorColumn指定字段名称（类型）和它的值由剩余的实体类（Teaching和NonTeachingStaff）字段来指定。 创建Staff类的一个子类叫TeachingStaff.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.janzenzhang.spring4.jpa.entity;import javax.persistence.DiscriminatorValue;import javax.persistence.Entity;@Entity@DiscriminatorValue(value = "TS")public class TeachingStaff extends Staff &#123; private String qualification; private String subjectexpertise; public TeachingStaff( String sname, String qualification,String subjectexpertise ) &#123; super( sname ); this.qualification = qualification; this.subjectexpertise = subjectexpertise; &#125; public TeachingStaff( ) &#123; super( ); &#125; public String getQualification( ) &#123; return qualification; &#125; public void setQualification( String qualification ) &#123; this.qualification = qualification; &#125; public String getSubjectexpertise( ) &#123; return subjectexpertise; &#125; public void setSubjectexpertise( String subjectexpertise ) &#123; this.subjectexpertise = subjectexpertise; &#125;&#125; 创建Staff 的一个子类叫NonTeachingStaff.java 12345678910111213141516171819202122232425262728293031323334package com.janzenzhang.spring4.jpa.entity;import javax.persistence.DiscriminatorValue;import javax.persistence.Entity;@Entity@DiscriminatorValue(value = "NS")public class NonTeachingStaff extends Staff &#123; private String areaexpertise; public NonTeachingStaff( String sname, String areaexpertise ) &#123; super( sname ); this.areaexpertise = areaexpertise; &#125; public NonTeachingStaff( ) &#123; super( ); &#125; public String getAreaexpertise( ) &#123; return areaexpertise; &#125; public void setAreaexpertise( String areaexpertise ) &#123; this.areaexpertise = areaexpertise; &#125;&#125; 服务类 服务类业务组件的实现部分。创建一个给定的包下名为SaveClient.java用来存储Staff，TeachingStaff和NonTeachingStaff类字段类。SaveClient类如下所示： 1234567891011121314151617181920212223242526272829303132package com.janzenzhang.spring4.jpa.service;import com.janzenzhang.spring4.jpa.entity.NonTeachingStaff;import com.janzenzhang.spring4.jpa.entity.TeachingStaff;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.Persistence;public class SaveClient &#123; public static void main(String[] args) &#123; EntityManagerFactory emfactory = Persistence.createEntityManagerFactory("defaultPersistenceUnit"); EntityManager entitymanager = emfactory.createEntityManager(); entitymanager.getTransaction().begin(); TeachingStaff ts1 = new TeachingStaff("Gopal","MSc MEd","Maths"); TeachingStaff ts2=new TeachingStaff( "Manisha", "BSc BEd", "English"); //Non-Teaching Staff entity NonTeachingStaff nts1=new NonTeachingStaff( "Satish", "Accounts"); NonTeachingStaff nts2=new NonTeachingStaff( "Krishna", "Office Admin"); entitymanager.persist(ts1); entitymanager.persist(ts2); entitymanager.persist(nts1); entitymanager.persist(nts2); entitymanager.getTransaction().commit(); entitymanager.close(); emfactory.close(); &#125;&#125; 执行上述代码后，查询Mysql数据库，会得到staff表，其数据如下所示： JPA实体映射关系通常关系都是用来描述数据库不同表的联系。这里实体类也被当做关系性的表（JPA中的概念），因此实体类之间的关系有以下几种： @ManyToOne @OneToMany @OneToOne @ManyToMany 注解在实体中使用到的注解列表如下： 注解 描述 @Entity 声明类为实体或表。 @Table 声明表名。 @Basic 指定非约束明确的各个字段 @Embedded 指定类或它的值是一个可嵌入的类的实例的实体的属性。 @Id 指定的类的属性，用于标识主键。 @GeneratedValue 指定主键生成方式，例如自动，手动，或从序列表中获得的值。 @Transient 该值永远不会存储在数据库中。 @Lob 将属性持久化为 Blob 或者 Clob 类型。 @Column 指定字段属性。 @SequenceGenerator 指定在 @GeneratedValue 注解中指定的属性的值。它创建了一个序列。 @TableGenerator 指定在 @GeneratedValue 批注指定属性的值发生器。它创造了的值生成的表。 @AccessType 这种类型的注释用于设置访问类型。 @JoinColumn 指定一个实体组织或实体的集合。这是用在多对一和一对多关联。 @UniqueConstraint 指定的字段和用于主要或辅助表的唯一约束。 @ColumnResult 参考使用 select 子句的 SQL 查询中的列名。 @ManyToMany 定义了连接表之间的多对多一对多的关系。 @ManyToOne 定义了连接表之间的多对一的关系。 @OneToMany 定义了连接表之间存在一个一对多的关系。 @OneToOne 定义了连接表之间有一个一对一的关系。 @NamedQueries 指定命名查询的列表。 @NamedQuery 指定使用静态名称的命名查询。 1、@OneToOne:一对一映射注解，双向的一对一关系需要在关系维护端(owner side)的 @OneToOne 注解中添加 mappedBy 属性，建表时在关系被维护端(inverse side)建立外键指向关系维护端的主键列。 用法：@OneToOne(optional=true,casecade=CasecadeType.ALL,mappedBy=”被维护端外键”) 2、@OneToMany一对多映射注解，双向一对多关系中，一端是关系维护端(owner side)，只能在一端添加 mapped 属性。多端是关系被维护端(inverse side)。建表时在关系被维护端(多端)建立外键指向关系维护端(一端)的主键列。 用法：@OneToMany(mappedBy = &quot;维护端(一端)主键&quot;, cascade=CascadeType.ALL) 注意： 在Hibernate中有个术语叫做维护关系反转，即由对方维护关联关系，使用 inverse=false 来表示关系维护放，在JPA的注解中，mappedBy就相当于inverse=false，即由mappedBy来维护关系。 3、＠ManyToOne 多对一映射注解，在双向的一对多关系中，一端一方使用 @OneToMany 注解，多端的一方使用 @ManyToOne 注解。多对一注解用法很简单，它不用维护关系。 用法：@ManyToOne(optional = false, fetch = FetchType.EAGER) 4、@ManyToMany 多对多映射，采取中间表连接的映射策略，建立的中间关系表分别引入两边的主键作为外键，形成两个多对一关系。 双向的多对多关系中，在关系维护端(owner side)的 @ManyToMany 注解中添加 mappedBy 属性，另一方是关系的被维护端(inverse side)，关系的被维护端不能加 mappedBy 属性，建表时，根据两个多端的主键生成一个中间表，中间表的外键是两个多端的主键。 用法： 关系维护端——&gt; @ManyToMany(mappedBy=&quot;另一方的关系引用属性&quot;) 关系被维护端——&gt; @ManyToMany(cascade=CascadeType.ALL ,fetch = FetchType.Lazy) 举例多对一实体之间存在的关系，其中一个实体（列或组列）引用了另一个包含唯一值实体（列或组列）。在关系数据库中，这些关系是通过使用表之间的外键/主键应用。 让我们考虑Employee和Department 实体之间的关系的一个例子。在单向方式，即从员工到部门，多到一的关系是可行的。这意味着员工每个记录包含一个部门ID，它应该是在部门表的主键。在这里，在Employee表，Department 的ID是外键。 下图显示了两个表之间的多对一关系 创建实体 Department.java1234567891011121314151617181920212223242526272829303132333435package com.janzenzhang.spring4.jpa.entity;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;@Entitypublic class Department &#123; @Id @GeneratedValue( strategy=GenerationType.AUTO ) private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName( ) &#123; return name; &#125; public void setName( String deptName ) &#123; this.name = deptName; &#125;&#125; Employee.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.janzenzhang.spring4.jpa.entity;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.ManyToOne;@Entitypublic class Employee &#123; @Id @GeneratedValue( strategy= GenerationType.AUTO ) private int eid; private String ename; private double salary; private String deg; @ManyToOne private Department department; public Employee(int eid, String ename, double salary, String deg) &#123; super( ); this.eid = eid; this.ename = ename; this.salary = salary; this.deg = deg; &#125; public Employee( ) &#123; super(); &#125; public int getEid( ) &#123; return eid; &#125; public void setEid(int eid) &#123; this.eid = eid; &#125; public String getEname( ) &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public double getSalary( ) &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public String getDeg( ) &#123; return deg; &#125; public void setDeg(String deg) &#123; this.deg = deg; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125;&#125; 服务类 实现了属性初始化关系的一部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.janzenzhang.spring4.jpa.service;import com.janzenzhang.spring4.jpa.entity.Department;import com.janzenzhang.spring4.jpa.entity.Employee;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.Persistence;public class ManyToOne &#123; public static void main(String[] args) &#123; EntityManagerFactory emfactory = Persistence. createEntityManagerFactory( "defaultPersistenceUnit" ); EntityManager entitymanager = emfactory. createEntityManager( ); entitymanager.getTransaction( ).begin( ); //Create Department Entity Department department = new Department(); department.setName("Development"); //Store Department entitymanager.persist(department); //Create Employee1 Entity Employee employee1 = new Employee(); employee1.setEname("Satish"); employee1.setSalary(45000.0); employee1.setDeg("Technical Writer"); employee1.setDepartment(department); //Create Employee2 Entity Employee employee2 = new Employee(); employee2.setEname("Krishna"); employee2.setSalary(45000.0); employee2.setDeg("Technical Writer"); employee2.setDepartment(department); //Create Employee3 Entity Employee employee3 = new Employee(); employee3.setEname("Masthanvali"); employee3.setSalary(50000.0); employee3.setDeg("Technical Writer"); employee3.setDepartment(department); //Store Employees entitymanager.persist(employee1); entitymanager.persist(employee2); entitymanager.persist(employee3); entitymanager.getTransaction().commit(); entitymanager.close(); emfactory.close(); &#125;&#125; 执行结果 参考文章 [1] JPA的使用 [2] JPA教程 [3] JPA学习笔记1——JPA基础]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 装饰器学习心得]]></title>
      <url>%2F2017%2F04%2F28%2FPython-%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[前言python的装饰器理解对我而言，一直是一个较为难以掌握的Python概念和语法糖。作为23种设计模式中的一种，装饰器模式本身并不难理解，尤其是是Java中IO流的操作，可以说是应用装饰器模式的一个很好范例。 但是由于Python支持一些函数式编程的特性，对于装饰器模式的实现相比较于Java这种传统的面相对象语言(忽略Java 8)，确实优雅不少，当然也增加了不少我们理解的成本。我将试图以我的理解来谈一谈Python装饰器这颗语法糖。 预备知识 高阶函数：能接受函数做参数的函数 在python的哲学里，一切皆对象。当然函数也就是一个对象，因此可以将其作为一个参数传入到函数里 例如map()就是典型的高阶函数 123print(list(map(lambda x: x*x,[1,2,3,4])))输出：[1, 4, 9, 16] 例如map()就是传入一个函数和一个列表，函数会对列表中的每一个值进行映射，并将结果以一个列表的形式返回。这里传入的是一个lambda函数，显然map()就是一个高阶函数 内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。 12345678910111213def voice(word): def smile(): print (word+&apos;...&apos;) return smileprint(voice(&apos;haha&apos;))voice(&apos;haha&apos;)()f = voice(&apos;haha&apos;) #将返回的函数绑定到f上f() #对f的调用本质上是对smile()的调用#输出：#&lt;function voice.&lt;locals&gt;.smile at 0x0000027BED1D9840&gt;#haha... 显然voice()和smile()构成了闭包，smile()引用了voice()的参数voice(&#39;haha&#39;)只是调用了外层函数，因此其返回结果为一个函数，如果再次对其调用，才会执行print (word+&#39;...&#39;),例如voice(&#39;haha&#39;)(),甚至可以将voice(‘haha’)结果绑定到一个变量上，然后再执行这个变量 装饰器这里我们传入的是一个字符串，如果传入的是一个函数那么会发生什么有意思的事情呢？ 1234567891011121314151617181920212223def decorator(fn): print("calling decorator()") def wrapper(): print("before call %s()" %fn.__name__) fn() print("after call %s()" %fn.__name__) return wrapperdef decorated(): print("This is a decorated function")decorator(decorated)print("-------------------")decorator(decorated)()#执行输出：#calling decorator()#-------------------#calling decorator()#before call decorated()#This is a decorated function#after call decorated() 我们只是把传入的变量由字符串变成了函数，并且在内层函数中执行了传入的函数。结果我们发现神奇的事情发生了，被传入的函数功能得到了丰富，在执行之前与执行之后，都可以执行一些其他的功能。显然我们已经达到了装饰器的目的。 没错！这就是python装饰器的实现。这里我们再换用一种写法，也就是python为我们提供的那颗语法糖 12345678910111213141516171819202122def decorator(fn): print(&quot;calling decorator()&quot;) def wrapper(): print(&quot;before call %s()&quot; %fn.__name__) fn() print(&quot;after call %s()&quot; %fn.__name__) return wrapper @decoratordef decorated(): print(&quot;This is a decorated function&quot;)decorated()#输出：# calling decorator()# before call decorated()# his is a decorated function# after call decorated() 显然我们的输出没有任何变化，也就是说我们的装饰器得到了正确的执行。那么@decorator做了什么事情呢？ 1decorated = decorator(decorated) 首先被装饰函数传入装饰函数，然后将结果重新绑定到被装饰函数名称上 向被装饰的函数传递参数显然python这颗语法糖让我们的代码得到了简化。但是这里的被装饰函数不带参数，那么是否可以带参数呢？如果可以，又应该在哪添加参数呢？ 123456789101112131415161718192021def decorator(fn): print(&quot;calling decorator()&quot;) def wrapper(s1, s2): print(&quot;before call %s()&quot; %fn.__name__) fn(s1,s2) print(&quot;after call %s()&quot; %fn.__name__) return wrapper@decoratordef decorated(s1, s2): print(&quot;This is a decorated function.My parameters are %s and %s&quot;%(s1,s2))decorated(&quot;hello&quot;, &quot;world&quot;)# 输出# calling decorator()# before call decorated()# This is a decorated function.My parameters are hello and world# after call decorated() 这里我们是向内层函数wrapper()传递了参数，由于在调用装饰器返回的函数实际上是调用wrapper()这个函数，可以把参数写传给它，然后由它传给被装饰的原函数 向装饰器传递参数如果我们是想向装饰器传递参数，那么又当如何？之前的装饰器必须接受一个函数作为参数，但不能把被修饰的函数直接传递给装饰器。另一方面我们可以发现内层函数的参数可以从外层的函数参数获取，那么这种思想是否也可以运用到装饰器中呢？ 1234567891011121314151617181920212223242526def decorator_maker(arg1, arg2): def decorator(fn): print(&quot;calling decorator() You passed me arguments: %s and %s&quot;%(arg1, arg2)) def wrapper(): print(&quot;before call %s()&quot; %fn.__name__) fn() print(&quot;after call %s()&quot; %fn.__name__) return wrapper return decoratordef decorated(): print(&quot;This is a decorated function&quot;)a = decorator_maker(&quot;hello&quot;, &quot;world&quot;) # a实际上是decorator函数b = a(decorated) # b实际上是wrapper函数b()# 输出# calling decorator() You passed me arguments: hello and world# before call decorated()# This is a decorated function# after call decorated() 显然装饰器获取到了参数，我们的目的达到了，下面我们将简化这种调用的写法 123decorated_function = decorator_maker(&quot;hello&quot;, &quot;world&quot;)(decorated)decorated_function() 我们用python装饰器语法糖来写的话就是 123456789101112131415161718def decorator_maker(arg1, arg2): def decorator(fn): print(&quot;calling decorator() You passed me arguments: %s and %s&quot;%(arg1, arg2)) def wrapper(): print(&quot;before call %s()&quot; %fn.__name__) fn() print(&quot;after call %s()&quot; %fn.__name__) return wrapper return decorator@decorator_maker(&quot;hello&quot;, &quot;world&quot;)def decorated(): print(&quot;This is a decorated function&quot;)decorated() 如果我们再把被装饰的函数的参数也引入的话，应该这样写 123456789101112131415161718def decorator_maker(arg1, arg2): def decorator(fn): print(&quot;calling decorator() You passed me arguments: %s and %s&quot;%(arg1, arg2)) def wrapper(s1, s2): print(&quot;before call %s()&quot; %fn.__name__) fn(s1, s2) print(&quot;after call %s()&quot; %fn.__name__) return wrapper return decorator@decorator_maker(&quot;hello&quot;, &quot;world&quot;)def decorated(s1, s2): print(&quot;This is a decorated function. My parameters are %s and %s&quot;%(s1, s2))decorated(&quot;welcome&quot;, &quot;Beijing&quot;) 装饰对象的方法由于python中对象的方法和函数是很相似的。唯一的不同就是方法的第一个参数必须是self. 1234567891011121314151617def decorator(method): def wrapper(self, lie): lie = lie -4 method(self, lie) return wrapperclass Person(object): def __init__(self): self.age = 26 @decorator def sayYourAge(self, lie): print(&quot;I am %s years old&quot;%(self.age +lie))I = Person()I.sayYourAge(-3) 总结其实装饰器能够传递参数的原因是由于闭包特性 也许你会有个疑问：我可以用装饰器做什么，它看起来很好很强大，但是如果有个实际例子会更好。 关于在什么情况下使用有很多种可能，传统的用法是当你需要扩展一个外部库函数的行为或者处于debug的需要（但你不想对其直接做做更改，因为这只是临时的），你可以使用一个装饰器来扩展许多函数，不要重写每个函数（DRY原则） 这一次我们只是简单的讨论了装饰器的写法，后面一篇文章我们将讨论装饰器一些更加本质的东西]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于IT技术学习的一点思考]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%85%B3%E4%BA%8EIT%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[写在最前面“男怕入错行，女怕嫁错郎”这是我从小就深知的道理。或许我真的进错了行业，IT行业的发展实在过于迅速，所以导致我目前学习IT技术有了一种“应接不暇”的感觉。旧技术还没掌握，新技术就已经热了起来，甚至趋于成熟。我相信很多人都有类似的这种感觉。面对这种情况，很多人都会固步自封，不再去继续学习，或者直接放弃。当然还是会有少部分人，始终站在技术的最前线，依旧努力学习着，思考着。个人觉得，这几种选择没有对与错之分，只要能找到最适合自己的并且不留遗憾，或许就是最好的选择。 既然我选择了后者，我也顾不上诗和远方，只有风雨兼程了。当然我写这篇水文的目的是希望将关于技术选型以及技术成长方面自己的一些思考，记录下来。在技术呈井喷式发展的时代里，或许我们真的需要停下来思考，想想什么样的技术适合自己，什么样的技术是强势技术，如何快速的提高自己来适应这个操蛋的IT圈。 关于技术选型编程语言的选择编程语言的争论一直就有，什么样的编程语言好，什么样的语言不好，众说纷纭。我把这些争论一直当作段子来看待。如果有人问我什么样的编程语言最好，我一定会告诉他是PHP是全世界最好的编程语言（我自己从来没有学习过PHP，别人都这么说那我也这么说咯）。 但是我想表达的是，我们不应该在陷入这种无聊的争议当中。作为一个初学者，我们应该选定一门编程语言，然后深入下去。一般来说，最重要的是一个码农的编程思想而不是他使用的是哪一种语言。而且通常来说，大牛都熟练掌握至少4门编程语言。语言的差别不应该是你编程入门的障碍。相反，我们需要很好的使用一门编程语言来解决我们实际中的问题，然后不断锤炼自己的编程思想，进而提高自己的编程水平。不可否认的是不同编程语言确实各有优势，有自己擅长的领域，但是作为初学者绝大多数问题都是可以用好几种编程语言解决的，不会存在某种语言解决不了的问题。 拿我自己来说的话，真正意义上系统学习编程是在大四。虽然起点足够晚，但是我从来没有放弃过提升自己的编程水平，我相信通过自己的努力总会是龟兔赛跑中的那个乌龟的。在我选择语言上也曾纠结过较长一段时间，一个是C++，一个是JAVA。学长给我说C++ 全能，从底层到上层什么都可以做，建议我学习C++。但是我学习了一个多月后，我确实还是被C++ 繁杂的语法规则折磨的死去活来。好在这个时候接触到了JAVA，没有了指针，不用区分什么值传递、地址传递、引用传递。我得到了解脱，从此爱上了JAVA。尤其是接触了jdk之后真的感觉整个人都爽了起来，很多底层的东西不用管了，我可以更加专注于自己的程序逻辑了。还有jdk自带的swing库就可以让我写出图形界面。 而C++ 需要搭配MFC或者Qt。当你自己第一次写出图形化界面的那种喜悦感，还是真的很开心的。 我想表达的并不是JAVA比C++ 好这种观点，只是想强调找一个适合自己的语言，或许能让你快速开始自己的编程生活。而且JAVA确实还有很多事情做不到，但是C++ 可以。个人学习了几门编程语言之后，以及受到一些大神的指定之后，还是得出了这样一个结论： 我们最好掌握一门静态语言（C++ java），一门动态语言（Python Javascript） 动态语言有很多静态语言不具有的优势，当然也会存在自身的一些不足。我们需要去接触动态语言，学习了一门动态语言之后，对之前学习过的静态语言理解也会加深。我们不能仅仅停留在本科老师讲课的那些知识或者某种编程语言，毕竟现实世界的问题过于复杂，我们课本上那些仅有的知识很难解决所有的问题。 技术成长的一点思考其实编程虽然很重要，但只是IT知识中很小的一部分。要想全面提高自己还需要学习很多计算机方面的基础知识。比如操作系统、数据库、数据结构、计算机网络等知识。这些基础知识其实基本上在本科的时候都已经学习过，但是大部分人却没有使用过。这些基础知识如同编程水平一般重要，对于一个IT技术人员是不可或缺的。 对于枯燥难懂的上述理论知识，我个人更倾向于通过一些具体的IT技能去理解。比如学习操作系统就可以通过Linux，学习数据库可以通过自己搭建mysql，学习计算机网络知识可以通过wireshark抓包以及一些仿真平台去模拟。其中每一项基础知识的掌握，都需要花费大量时间，当然也很值得。如果你能精通其中任何一门基础知识，找个工作的完全没有压力。 如果你觉得掌握这些基础知识就大功告的话，那只能说naive。课程内的知识固然重要，但是作为科技界的弄潮儿，我们还需要紧跟时代发展的脚本。除了书本上常见的这些知识外，还有一些很重要基础知识，已经广泛应用于各个领域。比如 XML（包括Scheme）、Json 设计模式 Git、SVN Maven、Gradle 根据自己的发展方向还有很多知识，比如数据库工程师除了传统的关系型数据库，还得学习非关系数据库，比如后端工程师还得学习各种框架、熟练掌握多线程并发编程技术。比如偏底层的云计算工程师，还得掌握各种虚拟化技术，以及某种云计算架构。如果是前端工程师，那各种眼花缭乱的各种框架就如同家常便饭。 其实我在学习Javascript的时候，也有网上的说话说直接学习jquery就行了，何必学习Javascript。确实我必须承认jquery可以解决我的所有问题，但是jquery毕竟只是Javascript的一个库。如果放弃学习Javascript，直接学习jquery，有点舍本逐末的感觉。 当然这么多技术确实想要短时间全盘掌握，确实不太可能。但是作为初学者我们更应该打好基础，只有这样才有可能在学习新技术的时候得心应手，左右逢源。新技术并不是凭空产生，它一定是现有的技术无法解决现实生活中的某些问题，在现有技术的技术上发展而来的。其实仔细想来，IT的基础知识也不是那么多，花点时间总是可以掌握的。 写在最后的话IT技术发展这么多年后，并没有朝着简单化的方向发展。相反的是，它对于从业人员的要求越来越高，以前还分什么前端后端，现在直接就是全栈工程师，以前还分什么开发运维，现在Devops思想已经深入人心。或许留给我们初学者的只有孜孜不倦的求索，去学习掌握强势技术。另一方面，技术的学习肯定枯燥，纵然有热情和兴趣也是如此，这就需要我们沉下心来，点滴积累必然有所收获。 附关于业界技术、工具、语言的发展趋势分析以及预测报告可以参考： ThoughtWorks 学习C++可以参考如下书籍：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾Android开发]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%9B%9E%E9%A1%BEAndroid%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[前言本人在编程、软件开发方面确实是一个菜鸟，进入研究生阶段，才比较系统的学习编程（私底下）。实验室并不是做软件开发方向的，涉及到编程开发的内容相对较少。本人主要是出于兴趣，私底下学习编程。因此文中，有任何描述不专业的地方，请见谅。这完全是一篇作者闲来无事发的一篇即兴感慨。 第一次Android开发的经历这里用开发来形容好像并不准确，确切的说是尝试。大三的时候软件课程设计的需要，开发一款可以采集学校WLAN信号强度以及分布的APP。现在想想确实不难，WLAN强度以及SSID的获取很简单，而地图的功能相对来说可能难一点，但是只需要调用百度地图的SDK进行开发，应该也不是难事。相对麻烦一点，需要自己做的可能就是地图和采集到的WLAN数据进行一个整合。但是背后的逻辑显然也不是很难。 就是这样一个对于本科生来说，难度很正常的APP，让我对于Android开发有了那么一点点恐惧。说一下当时的技术背景吧，本科的我基本都在做电路相关的工作，主要是一些关于信号链的问题（装下逼），不装逼的说法是测量电路和嵌入式电路。而编程语言也只学过C，C++都不会的那种。其实C也基本属于菜鸟水平，面向对象更不知道是何物。按照现在的我来看，当时这种基础完全不适合进行Android开发。 但是由于学校课程的需要，我还是被赶鸭子上架，尝试去写这样一个Android应用。结果你们也应该猜到了，就是被搞得遍体鳞伤，体无完肤的那种。JAVA完全不会，甚至面向对象的概念都没有，怎么可能去理解人家的源码。至于配置文件，不管是布局文件还是文件也好，都是用XML写的。当时完全看不懂，只能跟着教程一步步来。就像和尚念经一样，完全是有口无心。 最后还好抱了一个大腿队友，强行带我这个坑，拿了班上第一名的好成绩。而我没有任何成就感，因为我没有贡献一行代码，完全是在打酱油。羞耻的事，说到这也差不多了 再次回眸昨天google刚上线了谷歌中国开发者的网站，这又激起了我对Android开发的兴趣。所以我特地下载了一个Android Studio，尽管我电脑上已经装了IntelliJ IDEA 。为了简单，还是选择直接安装studio。 打开界面发现还是有点似曾相识的感觉，基本配置和两年前用eclipse+ADT的配置差不多，通用设置比如字体这些调节当然和我熟悉的Intellij IDEA一样。所以在搭建环境上，速度很快 环境搭好之后，当然应该是跑一个Demo，我选择新建了一个Empty Activity，然后自己照着书增加了一个按钮，绑定了一个监听器，试了一下运用Intent在不用Activity之间切换以及传递数据。 我确实没有实现自己的任何逻辑代码，但是和两年前的自己相比，我觉得有很大不一样的是照着教程，也能很清楚的理解每一步在干什么了。不管是代码还是配置文件，我都看的一清二楚了。依旧要照着教程，我觉得只是对于Android平台还不够熟悉而言，当然也没有完全深入进去。至少理解起来，没有任何障碍 1234567891011Button button2 = (Button)findViewById(R.id.button_2);button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); Log.d("hello","hello world"); setResult(RESULT_OK, intent); finish(); &#125;&#125;); 比如上面这行代码Button button2 = (Button)findViewById(R.id.button_2);这句话利用传入R.id.button_2参数来返回得到一个相应的Button对象。其实功能根据方法的名称是可以猜出来的，当然我们也可以猜测传入的参数是int型，而得到的对象经过一次向下强制转换得到Button对象，那么我们有理由去推断，方法返回的类型应该是Button的父类View类，查一下源码发现果然是。其实类似的操作在集合中用的很多，有点像Map配合泛型使用的那种感觉。 下面的绑定监听器，自然是用了大名鼎鼎的装饰器模式，也采用匿名内部类的方式去书写，重写了Onclick()方法。这种和Swing编程中的绑定监听器几乎没有什么区别。自然得心应手. 1requestWindowFeature(Window.FEATURE_NO_TITLE); 上面的这句和swing编程this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);个人觉得也有异曲同工之妙，都是利用一个常量来设置属性参数，当然应该还有更相近的，但是暂时一下想不起来了~~ 1setContentView(R.layout.second_layout); 和this.setLayout(new GridLayout(2, 2));也差不多，只是一个传入的是常量，另一个传入的是一个对象的实例 至于Intent 12Intent intent = new Intent(MainActivity.this, SecondActivity.class);startActivityForResult(intent, 1); 个人觉得理解起来也很简单，甚至觉得比socket更简单。上面是用显式的方式去调用Intent，当然还有隐式的调用方式。 不过能够明显感受到Activity和Intent对于Android开发的重要性。像Activity的生命周期之类的，我觉得还是要深入了解的。 下面谈一下AndroidManifest.xml什么都不说，直接上代码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.hello"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" android:label="This is FirstActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.hello.ACTION_START" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".ThirdActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 大三的时候看到这个也只是一知半解，因为当时不知道XML为何物。其实我觉得要理解这个，只需要完全掌握XML的基本知识。不管这个东西是干啥的，反正就是一个XML文件，那么我就可以用XML的方式去理解它。 根节点是manifest，里面还有一些很重要的子节点像appication和activity,当然还有各种重要的属性。其实按照XML的结构去理解，我觉得还是可以理解个七八分。 当然还有layout.xml 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button_3" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 3"/&gt;&lt;/LinearLayout&gt; 除了节点就是属性，很显然属性对于刻画其中每个节点（对应于实际界面中的元素）。不管XML来描述界面是否合理，Android这种设计模式确实将界面与逻辑实现了分离，我觉得这是很重要的。 上面基本就是我花了一个小时左右时间，对于第二次接触Android的发现 结论其实写这篇随感，最终的目的就是这个结论。虽然目前我看Android依旧很肤浅，但是我觉得我有信心去掌握Android开发。在第一次和第二次接触Android的两年时间里，我觉得我并没有去接触过Android开发了，但是我觉得我的感触完全不同。只是因为我对于Android许多很基础的技术进行了储备，像JAVA SE和XML。显然我的付出还是得到了一些收获。 学习JAVA SE和XML的内容只是单纯为了学习J2EE所准备的。就像我的第一篇帖子中介绍的那样，我还在认真的学习J2EE相关的内容。第二次去接触Android开发完全是一时兴起。但是我依旧能够深切感受到技术之间是有相关性的，对于作为学生的我，我觉得最大的优势就是有时间去深入学习一门技术。我觉得这很重要，做技术的不能浅尝辄止，一定要深入。就像学习XML时，我除了理解XML的结构 ，也学习了Schema和DTD校验方式，当时还学习了如何用JAVA去解析XML文件。至于JAVA，我也尝试去深入理解面向对象的编程思想，对于JAVA中的每一个知识点，都力求彻底掌握。虽然目前学习的是J2EE，但是web开发和Android开发还是有相识的地方的，界面和背后的业务逻辑都进行了分离，只是一个界面是用了HTML+CSS这种，Android是用了XML。 最近发现阅读源码也很有意思。一方面，很多疑惑或者不解，看到源码就能秒懂，另一方面，通过阅读源码，也可以去接触大神是如何编写代码的，他们是如何实现这些功能并将API开放出来。我觉得对于提升个人编程水平也很有帮助。 当然目前来说，个人还是一个小菜鸟，还需要继续努力。暂时也不会继续深入学习Android开发了，我需要集中精力去学习J2EE的内容。就像我之前说的一样，个人认为技术不仅要有广度，更要有深度。所以我打算继续深入J2EE。希望有一天我第三次再来接触Android会有更加深刻的体会，也希望那时的我已经学成归来，可以深入Android下去。 路漫漫其修远兮，吾将上下而求索！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于openstack中Nova服务停止的解决办法]]></title>
      <url>%2F2016%2F11%2F29%2F%E5%85%B3%E4%BA%8Eopenstack%E4%B8%ADNova%E6%9C%8D%E5%8A%A1%E5%81%9C%E6%AD%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[背景Nova API服务是OpenStack控制系统的核心计算服务，我们可以通过他来管理和控制整个OpenStack系统，以及调度和管理虚拟机，也可以通过它调用系统中的其他服务 nova-compute服务负责在计算节点创建与运行虚拟机，安装步骤如下： 安装nova-compute-kvm,如下所示： 1apt-get install -y nova-compute-kvm 除此之外，nova-compute还有一堆配置文件 重启nova-compute服务 1service noca-compute restart 实际解决步骤 在compute节点上(node-25,对于我们的环境而言)，首先查看log信息，其具体位置在： 1/var/log/nova/nova-compute.log 重启libvirtd： 1service libvirtd start 重启nova-compute服务 1service nova-compute restart 友情链接重启openstack的服务命令集合 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[paramiko模块学习心得]]></title>
      <url>%2F2016%2F11%2F06%2Fparamiko%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[paramiko模块学习心得简介Paramiko is a Python (2.6+, 3.3+) implementation of the SSHv2 protocol [1], providing both client and server functionality. While it leverages a Python C extension for low level cryptography (Cryptography), Paramiko itself is a pure Python interface around SSH networking concepts. paramiko是python的一个模块，实现了SSH2协议，支持了客户端和服务器的功能。使用paramiko模块主要实现和远程服务器的文件上传、下载和执行命令。 安装1pip install paramiko windows和Ubuntu下都可以采用此方式安装 使用paramiko执行命令paramiko_client.py123456789101112131415161718192021222324252627282930313233343536373839import paramikoimport configparserclass ParamikoClient: def __init__(self, config_str): self.config = configparser.ConfigParser() self.config.read(config_str) #获取SSHClient对象 self.client = paramiko.SSHClient() #运行连接不在know_hosts文件中的主机 self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) self.sftp_client = None def connect(self): try: #注意对于配置文件中不同参数，要根据数据类型采用不同的方法取出，整型的采用getint self.client.connect(hostname=self.config.get('ssh', 'host'), port=self.config.getint('ssh', 'port') , username=self.config.get('ssh', 'username'), password=self.config.get('ssh', 'password') , timeout=self.config.getfloat('ssh', 'timeout')) except Exception as e: print(e) try: self.client.close() except: pass def run_cmd(self, cmd_str): stdin, stdout, stderr = self.client.exec_command(cmd_str) for line in stdout: print(line) #可以发现SFTPClient的建立借助于之前建立好的SSH连接，即self.client def get_sftp_client(self): if not self.sftp_client: self.sftp_client = paramiko.SFTPClient.from_transport(self.client.get_transport()) return self.sftp_client 在代码中引入configparser模块是为了解析配置文件config.ini 整体模块采用了面向对象的编程思想来用类对数据和方法进行封装。 exec_cmd.py 123456from paramiko_client import ParamikoClientif __name__ == '__main__': client = ParamikoClient('config.ini') client.connect() client.run_command('date') 为了实现代码良好的封装性，并且减少硬编码的影响，这里采用了读取配置文件的方式，加载链接所需要的必要参数，即config.iniconfig.ini 123456[ssh]host=192.168.3.137port=22username=zhangpassword=116113timeout=1.0 上传文件upload_file.py 123456789from paramiko_client import ParamikoClientclient = ParamikoClient('config.ini')client.connect()sftp_client = client.get_sftp_client()sftp_client.put('C:\\Users\\JanzenZhang\\Desktop\\network_aware.py', '/home/zhang/network_aware.py') 一定要保证在执行get_sftp_client()之前已经执行了client.connect() 下载文件download_file.py1234567from paramiko_client import ParamikoClientclient = ParamikoClient('config.ini')client.connect()sftp_client = client.get_sftp_client()sftp_client.get('/home/zhang/res.txt','C:\\Users\\JanzenZhang\\Desktop\\res.txt') 不管是上传还是下载文件，第一个参数的位置传递的都是源文件的地址。 测试环境以上代码本人均在本机以及本机上的Ubuntu 16.04虚拟主机之间测试通过 代码参考了麦子学院教程 拓展性结合python的多线程方法，可以实现多个文件的同时上传和下载，也可以同时和多个服务器进行文件传输 友情链接paramiko官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Configure Juju for OpenStack]]></title>
      <url>%2F2016%2F10%2F19%2FConfigure-Juju-for-OpenStack%2F</url>
      <content type="text"><![CDATA[前言鉴于目前网上关于Juju的资料很少，而且大部分都是介绍如何利用Juju部署Openstack环境。而这里我们将介绍如何基于本地的私有云(OpenStack)配置Juju。 Juju简介Juju 是 Canonical 公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu 服务器、OpenStack、用于裸机配置的MAAS 、以及 用于系统管理和监控的Landscape 一起组成 Ubuntu 云套件。 Juju安装官方安装教程地址 在Ubuntu下安装方式为(以Juju1.25版本为例) 12sudo add-apt-repository ppa:juju/stablesudo apt-get update &amp;&amp; sudo apt-get install juju-core 基于私有云OpenStack配置Juju生成Juju配置文件1juju generate-config 执行上述命令后，就会在路径~/.juju/下生成environments.yaml文件 下面我们要配置environments.yaml文件 在配置environments.yaml文件时，我们需要一个工具进行辅助来获得一些必要的参数，它就是Functest。 安装Functest(假定你已经安装好了docker环境) 1docker pull functest:latest 为Functest设置一些环境变量： 12env_vars=&quot;-e INSTALLER_TYPE=fuel -e INSTALLER_IP=10.20.0.2 -e DEPLOY_SCENARIO=os-nosdn-nofeature-noha&quot;result_vol=&quot;-v &#123;your_path&#125;/results:/home/opnfv/functest/results&quot; 这里your_path指定为一个已知的路径，用来存放结果 下载并在rocker容器中运行functest 1sudo docker run -id --privileged=true --name functest_demo $env_vars $results_vol opnfv/functest 进入docker容器 1sudo docker exec -ti functest_demo /bin/bash 在运行functest之前，需要准备环境变量 1functest env prepare Tips:如果在执行这条命令时，卡在了验证网络连通性的地方，很有可能是由于网卡没有配置VLAN，需要设置子网卡，并配置相应的VLAN tag。这部分应该和安装OpenStack时的网络VLAN划分保持一致。 在docker环境内，在/home/opnfv/functest/conf下找到文件openstack.creds，并用vi打开。 退出docker环境，在主机上找到路径~/.juju/下的enviroments.yaml文件，并用vi打开，主要是对openstack词条下的环境变量进行编辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type: openstack# use-floating-ip specifies whether a floating IP address is# required to give the nodes a public IP address. Some# installations assign public IP addresses by default without# requiring a floating IP address.## use-floating-ip: false# use-default-secgroup specifies whether new machine instances# should have the "default" Openstack security group assigned.## use-default-secgroup: false# network specifies the network label or uuid to bring machines up# on, in the case where multiple networks exist. It may be omitted# otherwise.## network: &lt;your network label or uuid&gt;# tools-metadata-url specifies the location of the Juju tools and# metadata. It defaults to the global public tools metadata# location https://streams.canonical.com/tools.## tools-metadata-url: https://your-tools-metadata-url# image-metadata-url specifies the location of Ubuntu cloud image# metadata. It defaults to the global public image metadata# location https://cloud-images.ubuntu.com/releases.## image-metadata-url: https://your-image-metadata-url# image-stream chooses a simplestreams stream to select OS images# from, for example daily or released images (or any other stream# available on simplestreams).## image-stream: "released"# auth-url defaults to the value of the environment variable# OS_AUTH_URL, but can be specified here.## auth-url: https://yourkeystoneurl:443/v2.0/# tenant-name holds the openstack tenant name. It defaults to the# environment variable OS_TENANT_NAME.## tenant-name: &lt;your tenant name&gt;# region holds the openstack region. It defaults to the# environment variable OS_REGION_NAME.## region: &lt;your region&gt;# The auth-mode, username and password attributes are used for# userpass authentication (the default).## auth-mode holds the authentication mode. For user-password# authentication, auth-mode should be "userpass" and username and# password should be set appropriately; they default to the# environment variables OS_USERNAME and OS_PASSWORD respectively.## auth-mode: userpass# username: &lt;your username&gt;# password: &lt;secret&gt;## For key-pair authentication, auth-mode should be "keypair" and# access-key and secret-key should be set appropriately; they# default to the environment variables OS_ACCESS_KEY and# OS_SECRET_KEY respectively.## auth-mode: keypair#access-key: &lt;secret&gt;# secret-key: &lt;secret&gt; 可以发现大部分环境变量在functest中都可以找到，下面是我们的环境变量设置情况： 其中use-floating-ip，use-default-secgroup均设置为falseagent-metadata-url，image-metadata-url的设置后面会提到，这里先不进行更改。region，auth-mode采用默认值，撤掉注释即可。network填写openstack一个私有网络即可。 关于这一部分的说明，见官网 使用Simplestreams建立私有云当使用Juju bootstrap云时，需要两种信息: The uuid of the image to use when starting new compute instances. The URL from which to download the correct version of a tools tarball. 我们可以简单的理解为上述两种信息都存储在两个json文件中。 其具体介绍可以参考官网 在生成上述两个文件之前要做一些准备工作： 上传Ubuntu 14.04LTS（Trusty）和Ubuntu 16.04LTS（Xenial）镜像到Openstack Trusty镜像下载地址 Xenial镜像下载地址 其中均选择 xxxxx-server-cloudimg-amd64-disk1.img 下载 然后就是上传到Openstack： 安装Apache服务器 1sudo apt-get install apache2 生成image json文件： 1sudo juju metadata generate-image -a amd64 -i 843bef24-8c70-40e1-a380-972717c9e4b3 -r RegionOne -s xenial -d /var/www/html/stack -u http://172.16.1.3:5000/v2.0 -e openstack 相应的命令行选项： -i 843bef24-8c70-40e1-a380-972717c9e4b3: specifies the ID of the Glance image that we just created before. -u http://172.16.1.3:5000/v2.0: specifies the Keystone URL, and should match the value from the auth-url field of our environment as specified in $HOME/.juju/environments.yaml. -e openstack: identifies the Juju environment described in $HOME/.juju/environments.yaml file. -s xenial: specifies the image series (the Ubuntu release name). -a amd64: specifies the CPU architecture. -d /var/www/html/stack: specifies the base directory where the metadata will be written to. For images, the path will be /opt/stack/images/streams/v1.. 生成tools json文件: 1juju metadata generate-tools -d /var/www/html/stack/ --stream released Tips: /var/www/html/为Apache服务器默认路径 校验生成的上述生成的文件 12juju metadata validate-imagesjuju metadata validate-tools 下载工具文件： 下载连接 并将其放到/var/www/html/stack/tools/released路径下 Tips:注意要下载和自己juju版本以及系统匹配的工具文件版本 更改上述文件的权限： 12cd /var/www/html/stacksudo chmod -R 777 ./* 最后就是bootstrap 12juju switch openstackjuju bootstrap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[没有想好标题的帖子]]></title>
      <url>%2F2016%2F09%2F28%2F%E6%B2%A1%E6%9C%89%E6%83%B3%E5%A5%BD%E6%A0%87%E9%A2%98%E7%9A%84%E5%B8%96%E5%AD%90%2F</url>
      <content type="text"><![CDATA[拖了这么久，我的blog终于搭建好了。从Pelican到Hexo，尝试了一些不同的开源工具。最后发现Hexo教程最为丰富，而且操作最为简便。虽然不是用熟悉的Python写的，但是可以让我专注于写作。 写blog最难的就是坚持把。我会争取好好坚持下来，用它记录我这三年的所学所悟所感。时光匆匆，之前生活过得太过匆忙。当我回首的时候，发现都没有记录下来，很是遗憾。现在有了这个静态博客网站就完全不一样了，我希望自己能用一种Geek的方式来记录我研究生三年的成长与蜕变 读研了很多东西都觉得不一样了，比如明白了导师为什么会叫Boss，发现实验室除了自学就是自学。没有本科的时候带你的学长了，有的只是各种催促项目进度。也发现了研究生阶段找对象将变得异常艰难。也许是身在帝都的原因把，就是感觉北邮的女生要求比华科的高。我甚至开始思考自己是否还要继续从事技术方向，为自己的出路感到迷茫。 作为一个有理想的年轻人，我相信迷茫都是暂时的。目前也基本确定了自己的技术方向，就是JAVA EE。所以blog未来可能会更多的涉及我在学习JAVA的感触与总结。选择这个方向包含自己的许多心酸与无奈。没有大数据，机器学习的背景，干不了那种高大上的热门方向。因为喜爱JAVA，又不想跟风做android方向，故选择了这个方向，深入接触之后，感觉还是很有意思的。但愿自己能继续保持一颗美好的好奇心，不灭的热情快乐地在技术道路上探索。吾生也有涯，蜕变也无涯。]]></content>
    </entry>

    
  
  
</search>
