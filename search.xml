<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[paramiko模块学习心得]]></title>
      <url>%2F2016%2F11%2F06%2Fparamiko%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[paramiko模块学习心得简介Paramiko is a Python (2.6+, 3.3+) implementation of the SSHv2 protocol [1], providing both client and server functionality. While it leverages a Python C extension for low level cryptography (Cryptography), Paramiko itself is a pure Python interface around SSH networking concepts. paramiko是python的一个模块，实现了SSH2协议，支持了客户端和服务器的功能。使用paramiko模块主要实现和远程服务器的文件上传、下载和执行命令。 安装1pip install paramiko windows和Ubuntu下都可以采用此方式安装 使用paramiko执行命令paramiko_client.py123456789101112131415161718192021222324252627282930313233343536373839import paramikoimport configparserclass ParamikoClient: def __init__(self, config_str): self.config = configparser.ConfigParser() self.config.read(config_str) #获取SSHClient对象 self.client = paramiko.SSHClient() #运行连接不在know_hosts文件中的主机 self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) self.sftp_client = None def connect(self): try: #注意对于配置文件中不同参数，要根据数据类型采用不同的方法取出，整型的采用getint self.client.connect(hostname=self.config.get(&apos;ssh&apos;, &apos;host&apos;), port=self.config.getint(&apos;ssh&apos;, &apos;port&apos;) , username=self.config.get(&apos;ssh&apos;, &apos;username&apos;), password=self.config.get(&apos;ssh&apos;, &apos;password&apos;) , timeout=self.config.getfloat(&apos;ssh&apos;, &apos;timeout&apos;)) except Exception as e: print(e) try: self.client.close() except: pass def run_cmd(self, cmd_str): stdin, stdout, stderr = self.client.exec_command(cmd_str) for line in stdout: print(line) #可以发现SFTPClient的建立借助于之前建立好的SSH连接，即self.client def get_sftp_client(self): if not self.sftp_client: self.sftp_client = paramiko.SFTPClient.from_transport(self.client.get_transport()) return self.sftp_client 在代码中引入configparser模块是为了解析配置文件config.ini 整体模块采用了面向对象的编程思想来用类对数据和方法进行封装。 exec_cmd.py 123456from paramiko_client import ParamikoClientif __name__ == &apos;__main__&apos;: client = ParamikoClient(&apos;config.ini&apos;) client.connect() client.run_command(&apos;date&apos;) 为了实现代码良好的封装性，并且减少硬编码的影响，这里采用了读取配置文件的方式，加载链接所需要的必要参数，即config.iniconfig.ini 123456[ssh]host=192.168.3.137port=22username=zhangpassword=116113timeout=1.0 上传文件upload_file.py 123456789from paramiko_client import ParamikoClientclient = ParamikoClient(&apos;config.ini&apos;)client.connect()sftp_client = client.get_sftp_client()sftp_client.put(&apos;C:\\Users\\JanzenZhang\\Desktop\\network_aware.py&apos;, &apos;/home/zhang/network_aware.py&apos;) 一定要保证在执行get_sftp_client()之前已经执行了client.connect() 下载文件download_file.py1234567from paramiko_client import ParamikoClientclient = ParamikoClient(&apos;config.ini&apos;)client.connect()sftp_client = client.get_sftp_client()sftp_client.get(&apos;/home/zhang/res.txt&apos;,&apos;C:\\Users\\JanzenZhang\\Desktop\\res.txt&apos;) 不管是上传还是下载文件，第一个参数的位置传递的都是源文件的地址。 测试环境以上代码本人均在本机以及本机上的Ubuntu 16.04虚拟主机之间测试通过 代码参考了麦子学院教程 拓展性结合python的多线程方法，可以实现多个文件的同时上传和下载，也可以同时和多个服务器进行文件传输 友情链接paramiko官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Configure Juju for OpenStack]]></title>
      <url>%2F2016%2F10%2F19%2FConfigure-Juju-for-OpenStack%2F</url>
      <content type="text"><![CDATA[前言鉴于目前网上关于Juju的资料很少，而且大部分都是介绍如何利用Juju部署Openstack环境。而这里我们将介绍如何基于本地的私有云(OpenStack)配置Juju。 Juju简介Juju 是 Canonical 公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu 服务器、OpenStack、用于裸机配置的MAAS 、以及 用于系统管理和监控的Landscape 一起组成 Ubuntu 云套件。 Juju安装官方安装教程地址 在Ubuntu下安装方式为(以Juju1.25版本为例) 12sudo add-apt-repository ppa:juju/stablesudo apt-get update &amp;&amp; sudo apt-get install juju-core 基于私有云OpenStack配置Juju生成Juju配置文件1juju generate-config 执行上述命令后，就会在路径~/.juju/下生成environments.yaml文件 下面我们要配置environments.yaml文件 在配置environments.yaml文件时，我们需要一个工具进行辅助来获得一些必要的参数，它就是Functest。 安装Functest(假定你已经安装好了docker环境) 1docker pull functest:latest 为Functest设置一些环境变量： 12env_vars=&quot;-e INSTALLER_TYPE=fuel -e INSTALLER_IP=10.20.0.2 -e DEPLOY_SCENARIO=os-nosdn-nofeature-noha&quot;result_vol=&quot;-v &#123;your_path&#125;/results:/home/opnfv/functest/results&quot; 这里your_path指定为一个已知的路径，用来存放结果 下载并在rocker容器中运行functest 1sudo docker run -id --privileged=true --name functest_demo $env_vars $results_vol opnfv/functest 进入docker容器 1sudo docker exec -ti functest_demo /bin/bash 在运行functest之前，需要准备环境变量 1functest env prepare Tips:如果在执行这条命令时，卡在了验证网络连通性的地方，很有可能是由于网卡没有配置VLAN，需要设置子网卡，并配置相应的VLAN tag。这部分应该和安装OpenStack时的网络VLAN划分保持一致。 在docker环境内，在/home/opnfv/functest/conf下找到文件openstack.creds，并用vi打开。 退出docker环境，在主机上找到路径~/.juju/下的enviroments.yaml文件，并用vi打开，主要是对openstack词条下的环境变量进行编辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type: openstack# use-floating-ip specifies whether a floating IP address is# required to give the nodes a public IP address. Some# installations assign public IP addresses by default without# requiring a floating IP address.## use-floating-ip: false# use-default-secgroup specifies whether new machine instances# should have the &quot;default&quot; Openstack security group assigned.## use-default-secgroup: false# network specifies the network label or uuid to bring machines up# on, in the case where multiple networks exist. It may be omitted# otherwise.## network: &lt;your network label or uuid&gt;# tools-metadata-url specifies the location of the Juju tools and# metadata. It defaults to the global public tools metadata# location https://streams.canonical.com/tools.## tools-metadata-url: https://your-tools-metadata-url# image-metadata-url specifies the location of Ubuntu cloud image# metadata. It defaults to the global public image metadata# location https://cloud-images.ubuntu.com/releases.## image-metadata-url: https://your-image-metadata-url# image-stream chooses a simplestreams stream to select OS images# from, for example daily or released images (or any other stream# available on simplestreams).## image-stream: &quot;released&quot;# auth-url defaults to the value of the environment variable# OS_AUTH_URL, but can be specified here.## auth-url: https://yourkeystoneurl:443/v2.0/# tenant-name holds the openstack tenant name. It defaults to the# environment variable OS_TENANT_NAME.## tenant-name: &lt;your tenant name&gt;# region holds the openstack region. It defaults to the# environment variable OS_REGION_NAME.## region: &lt;your region&gt;# The auth-mode, username and password attributes are used for# userpass authentication (the default).## auth-mode holds the authentication mode. For user-password# authentication, auth-mode should be &quot;userpass&quot; and username and# password should be set appropriately; they default to the# environment variables OS_USERNAME and OS_PASSWORD respectively.## auth-mode: userpass# username: &lt;your username&gt;# password: &lt;secret&gt;## For key-pair authentication, auth-mode should be &quot;keypair&quot; and# access-key and secret-key should be set appropriately; they# default to the environment variables OS_ACCESS_KEY and# OS_SECRET_KEY respectively.## auth-mode: keypair#access-key: &lt;secret&gt;# secret-key: &lt;secret&gt; 可以发现大部分环境变量在functest中都可以找到，下面是我们的环境变量设置情况： 其中use-floating-ip，use-default-secgroup均设置为falseagent-metadata-url，image-metadata-url的设置后面会提到，这里先不进行更改。region，auth-mode采用默认值，撤掉注释即可。network填写openstack一个私有网络即可。 关于这一部分的说明，见官网 使用Simplestreams建立私有云当使用Juju bootstrap云时，需要两种信息: The uuid of the image to use when starting new compute instances. The URL from which to download the correct version of a tools tarball. 我们可以简单的理解为上述两种信息都存储在两个json文件中。 其具体介绍可以参考官网 在生成上述两个文件之前要做一些准备工作： 上传Ubuntu 14.04LTS（Trusty）和Ubuntu 16.04LTS（Xenial）镜像到Openstack Trusty镜像下载地址 Xenial镜像下载地址 其中均选择 xxxxx-server-cloudimg-amd64-disk1.img 下载 然后就是上传到Openstack： 安装Apache服务器 1sudo apt-get install apache2 生成image json文件： 1sudo juju metadata generate-image -a amd64 -i 843bef24-8c70-40e1-a380-972717c9e4b3 -r RegionOne -s xenial -d /var/www/html/stack -u http://172.16.1.3:5000/v2.0 -e openstack 相应的命令行选项： -i 843bef24-8c70-40e1-a380-972717c9e4b3: specifies the ID of the Glance image that we just created before. -u http://172.16.1.3:5000/v2.0: specifies the Keystone URL, and should match the value from the auth-url field of our environment as specified in $HOME/.juju/environments.yaml. -e openstack: identifies the Juju environment described in $HOME/.juju/environments.yaml file. -s xenial: specifies the image series (the Ubuntu release name). -a amd64: specifies the CPU architecture. -d /var/www/html/stack: specifies the base directory where the metadata will be written to. For images, the path will be /opt/stack/images/streams/v1.. 生成tools json文件: 1juju metadata generate-tools -d /var/www/html/stack/ --stream released Tips: /var/www/html/为Apache服务器默认路径 校验生成的上述生成的文件 12juju metadata validate-imagesjuju metadata validate-tools 下载工具文件： 下载连接 并将其放到/var/www/html/stack/tools/released路径下 Tips:注意要下载和自己juju版本以及系统匹配的工具文件版本 更改上述文件的权限： 12cd /var/www/html/stacksudo chmod -R 777 ./* 最后就是bootstrap 12juju switch openstackjuju bootstrap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[没有想好标题的帖子]]></title>
      <url>%2F2016%2F09%2F28%2F%E6%B2%A1%E6%9C%89%E6%83%B3%E5%A5%BD%E6%A0%87%E9%A2%98%E7%9A%84%E5%B8%96%E5%AD%90%2F</url>
      <content type="text"><![CDATA[拖了这么久，我的blog终于搭建好了。从Pelican到Hexo，尝试了一些不同的开源工具。最后发现Hexo教程最为丰富，而且操作最为简便。虽然不是用熟悉的Python写的，但是可以让我专注于写作。 写blog最难的就是坚持把。我会争取好好坚持下来，用它记录我这三年的所学所悟所感。时光匆匆，之前生活过得太过匆忙。当我回首的时候，发现都没有记录下来，很是遗憾。现在有了这个静态博客网站就完全不一样了，我希望自己能用一种Geek的方式来记录我研究生三年的成长与蜕变 读研了很多东西都觉得不一样了，比如明白了导师为什么会叫Boss，发现实验室除了自学就是自学。没有本科的时候带你的学长了，有的只是各种催促项目进度。也发现了研究生阶段找对象将变得异常艰难。也许是身在帝都的原因把，就是感觉北邮的女生要求比华科的高。我甚至开始思考自己是否还要继续从事技术方向，为自己的出路感到迷茫。 作为一个有理想的年轻人，我相信迷茫都是暂时的。目前也基本确定了自己的技术方向，就是JAVA EE。所以blog未来可能会更多的涉及我在学习JAVA的感触与总结。选择这个方向包含自己的许多心酸与无奈。没有大数据，机器学习的背景，干不了那种高大上的热门方向。因为喜爱JAVA，又不想跟风做android方向，故选择了这个方向，深入接触之后，感觉还是很有意思的。但愿自己能继续保持一颗美好的好奇心，不灭的热情快乐地在技术道路上探索。吾生也有涯，蜕变也无涯。]]></content>
    </entry>

    
  
  
</search>
