<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python 装饰器学习心得]]></title>
      <url>%2F2017%2F04%2F28%2FPython-%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[前言python的装饰器理解对我而言，一直是一个较为难以掌握的Python概念和语法糖。作为23种设计模式中的一种，装饰器模式本身并不难理解，尤其是是Java中IO流的操作，可以说是应用装饰器模式的一个很好范例。 但是由于Python支持一些函数式编程的特性，对于装饰器模式的实现相比较于Java这种传统的面相对象语言(忽略Java 8)，确实优雅不少，当然也增加了不少我们理解的成本。我将试图以我的理解来谈一谈Python装饰器这颗语法糖。 预备知识 高阶函数：能接受函数做参数的函数 在python的哲学里，一切皆对象。当然函数也就是一个对象，因此可以将其作为一个参数传入到函数里 例如map()就是典型的高阶函数 123print(list(map(lambda x: x*x,[1,2,3,4])))输出：[1, 4, 9, 16] 例如map()就是传入一个函数和一个列表，函数会对列表中的每一个值进行映射，并将结果以一个列表的形式返回。这里传入的是一个lambda函数，显然map()就是一个高阶函数 内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。 12345678910111213def voice(word): def smile(): print (word+&apos;...&apos;) return smileprint(voice(&apos;haha&apos;))voice(&apos;haha&apos;)()f = voice(&apos;haha&apos;) #将返回的函数绑定到f上f() #对f的调用本质上是对smile()的调用#输出：#&lt;function voice.&lt;locals&gt;.smile at 0x0000027BED1D9840&gt;#haha... 显然voice()和smile()构成了闭包，smile()引用了voice()的参数voice(&#39;haha&#39;)只是调用了外层函数，因此其返回结果为一个函数，如果再次对其调用，才会执行print (word+&#39;...&#39;),例如voice(&#39;haha&#39;)(),甚至可以将voice(‘haha’)结果绑定到一个变量上，然后再执行这个变量 装饰器这里我们传入的是一个字符串，如果传入的是一个函数那么会发生什么有意思的事情呢？ 1234567891011121314151617181920212223def decorator(fn): print("calling decorator()") def wrapper(): print("before call %s()" %fn.__name__) fn() print("after call %s()" %fn.__name__) return wrapperdef decorated(): print("This is a decorated function")decorator(decorated)print("-------------------")decorator(decorated)()#执行输出：#calling decorator()#-------------------#calling decorator()#before call decorated()#This is a decorated function#after call decorated() 我们只是把传入的变量由字符串变成了函数，并且在内层函数中执行了传入的函数。结果我们发现神奇的事情发生了，被传入的函数功能得到了丰富，在执行之前与执行之后，都可以执行一些其他的功能。显然我们已经达到了装饰器的目的。 没错！这就是python装饰器的实现。这里我们再换用一种写法，也就是python为我们提供的那颗语法糖 12345678910111213141516171819202122def decorator(fn): print(&quot;calling decorator()&quot;) def wrapper(): print(&quot;before call %s()&quot; %fn.__name__) fn() print(&quot;after call %s()&quot; %fn.__name__) return wrapper @decoratordef decorated(): print(&quot;This is a decorated function&quot;)decorated()#输出：# calling decorator()# before call decorated()# his is a decorated function# after call decorated() 显然我们的输出没有任何变化，也就是说我们的装饰器得到了正确的执行。那么@decorator做了什么事情呢？ 1decorated = decorator(decorated) 首先被装饰函数传入装饰函数，然后将结果重新绑定到被装饰函数名称上 向被装饰的函数传递参数显然python这颗语法糖让我们的代码得到了简化。但是这里的被装饰函数不带参数，那么是否可以带参数呢？如果可以，又应该在哪添加参数呢？ 123456789101112131415161718192021def decorator(fn): print(&quot;calling decorator()&quot;) def wrapper(s1, s2): print(&quot;before call %s()&quot; %fn.__name__) fn(s1,s2) print(&quot;after call %s()&quot; %fn.__name__) return wrapper@decoratordef decorated(s1, s2): print(&quot;This is a decorated function.My parameters are %s and %s&quot;%(s1,s2))decorated(&quot;hello&quot;, &quot;world&quot;)# 输出# calling decorator()# before call decorated()# This is a decorated function.My parameters are hello and world# after call decorated() 这里我们是向内层函数wrapper()传递了参数，由于在调用装饰器返回的函数实际上是调用wrapper()这个函数，可以把参数写传给它，然后由它传给被装饰的原函数 向装饰器传递参数如果我们是想向装饰器传递参数，那么又当如何？之前的装饰器必须接受一个函数作为参数，但不能把被修饰的函数直接传递给装饰器。另一方面我们可以发现内层函数的参数可以从外层的函数参数获取，那么这种思想是否也可以运用到装饰器中呢？ 1234567891011121314151617181920212223242526def decorator_maker(arg1, arg2): def decorator(fn): print(&quot;calling decorator() You passed me arguments: %s and %s&quot;%(arg1, arg2)) def wrapper(): print(&quot;before call %s()&quot; %fn.__name__) fn() print(&quot;after call %s()&quot; %fn.__name__) return wrapper return decoratordef decorated(): print(&quot;This is a decorated function&quot;)a = decorator_maker(&quot;hello&quot;, &quot;world&quot;) # a实际上是decorator函数b = a(decorated) # b实际上是wrapper函数b()# 输出# calling decorator() You passed me arguments: hello and world# before call decorated()# This is a decorated function# after call decorated() 显然装饰器获取到了参数，我们的目的达到了，下面我们将简化这种调用的写法 123decorated_function = decorator_maker(&quot;hello&quot;, &quot;world&quot;)(decorated)decorated_function() 我们用python装饰器语法糖来写的话就是 123456789101112131415161718def decorator_maker(arg1, arg2): def decorator(fn): print(&quot;calling decorator() You passed me arguments: %s and %s&quot;%(arg1, arg2)) def wrapper(): print(&quot;before call %s()&quot; %fn.__name__) fn() print(&quot;after call %s()&quot; %fn.__name__) return wrapper return decorator@decorator_maker(&quot;hello&quot;, &quot;world&quot;)def decorated(): print(&quot;This is a decorated function&quot;)decorated() 如果我们再把被装饰的函数的参数也引入的话，应该这样写 123456789101112131415161718def decorator_maker(arg1, arg2): def decorator(fn): print(&quot;calling decorator() You passed me arguments: %s and %s&quot;%(arg1, arg2)) def wrapper(s1, s2): print(&quot;before call %s()&quot; %fn.__name__) fn(s1, s2) print(&quot;after call %s()&quot; %fn.__name__) return wrapper return decorator@decorator_maker(&quot;hello&quot;, &quot;world&quot;)def decorated(s1, s2): print(&quot;This is a decorated function. My parameters are %s and %s&quot;%(s1, s2))decorated(&quot;welcome&quot;, &quot;Beijing&quot;) 装饰对象的方法由于python中对象的方法和函数是很相似的。唯一的不同就是方法的第一个参数必须是self. 1234567891011121314151617def decorator(method): def wrapper(self, lie): lie = lie -4 method(self, lie) return wrapperclass Person(object): def __init__(self): self.age = 26 @decorator def sayYourAge(self, lie): print(&quot;I am %s years old&quot;%(self.age +lie))I = Person()I.sayYourAge(-3) 总结其实装饰器能够传递参数的原因是由于闭包特性 也许你会有个疑问：我可以用装饰器做什么，它看起来很好很强大，但是如果有个实际例子会更好。 关于在什么情况下使用有很多种可能，传统的用法是当你需要扩展一个外部库函数的行为或者处于debug的需要（但你不想对其直接做做更改，因为这只是临时的），你可以使用一个装饰器来扩展许多函数，不要重写每个函数（DRY原则） 这一次我们只是简单的讨论了装饰器的写法，后面一篇文章我们将讨论装饰器一些更加本质的东西]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于IT技术学习的一点思考]]></title>
      <url>%2F2017%2F03%2F13%2F%E5%85%B3%E4%BA%8EIT%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[写在最前面“男怕入错行，女怕嫁错郎”这是我从小就深知的道理。或许我真的进错了行业，IT行业的发展实在过于迅速，所以导致我目前学习IT技术有了一种“应接不暇”的感觉。旧技术还没掌握，新技术就已经热了起来，甚至趋于成熟。我相信很多人都有类似的这种感觉。面对这种情况，很多人都会固步自封，不再去继续学习，或者直接放弃。当然还是会有少部分人，始终站在技术的最前线，依旧努力学习着，思考着。个人觉得，这几种选择没有对与错之分，只要能找到最适合自己的并且不留遗憾，或许就是最好的选择。 既然我选择了后者，我也顾不上诗和远方，只有风雨兼程了。当然我写这篇水文的目的是希望将关于技术选型以及技术成长方面自己的一些思考，记录下来。在技术呈井喷式发展的时代里，或许我们真的需要停下来思考，想想什么样的技术适合自己，什么样的技术是强势技术，如何快速的提高自己来适应这个操蛋的IT圈。 关于技术选型编程语言的选择编程语言的争论一直就有，什么样的编程语言好，什么样的语言不好，众说纷纭。我把这些争论一直当作段子来看待。如果有人问我什么样的编程语言最好，我一定会告诉他是PHP是全世界最好的编程语言（我自己从来没有学习过PHP，别人都这么说那我也这么说咯）。 但是我想表达的是，我们不应该在陷入这种无聊的争议当中。作为一个初学者，我们应该选定一门编程语言，然后深入下去。一般来说，最重要的是一个码农的编程思想而不是他使用的是哪一种语言。而且通常来说，大牛都熟练掌握至少4门编程语言。语言的差别不应该是你编程入门的障碍。相反，我们需要很好的使用一门编程语言来解决我们实际中的问题，然后不断锤炼自己的编程思想，进而提高自己的编程水平。不可否认的是不同编程语言确实各有优势，有自己擅长的领域，但是作为初学者绝大多数问题都是可以用好几种编程语言解决的，不会存在某种语言解决不了的问题。 拿我自己来说的话，真正意义上系统学习编程是在大四。虽然起点足够晚，但是我从来没有放弃过提升自己的编程水平，我相信通过自己的努力总会是龟兔赛跑中的那个乌龟的。在我选择语言上也曾纠结过较长一段时间，一个是C++，一个是JAVA。学长给我说C++ 全能，从底层到上层什么都可以做，建议我学习C++。但是我学习了一个多月后，我确实还是被C++ 繁杂的语法规则折磨的死去活来。好在这个时候接触到了JAVA，没有了指针，不用区分什么值传递、地址传递、引用传递。我得到了解脱，从此爱上了JAVA。尤其是接触了jdk之后真的感觉整个人都爽了起来，很多底层的东西不用管了，我可以更加专注于自己的程序逻辑了。还有jdk自带的swing库就可以让我写出图形界面。 而C++ 需要搭配MFC或者Qt。当你自己第一次写出图形化界面的那种喜悦感，还是真的很开心的。 我想表达的并不是JAVA比C++ 好这种观点，只是想强调找一个适合自己的语言，或许能让你快速开始自己的编程生活。而且JAVA确实还有很多事情做不到，但是C++ 可以。个人学习了几门编程语言之后，以及受到一些大神的指定之后，还是得出了这样一个结论： 我们最好掌握一门静态语言（C++ java），一门动态语言（Python Javascript） 动态语言有很多静态语言不具有的优势，当然也会存在自身的一些不足。我们需要去接触动态语言，学习了一门动态语言之后，对之前学习过的静态语言理解也会加深。我们不能仅仅停留在本科老师讲课的那些知识或者某种编程语言，毕竟现实世界的问题过于复杂，我们课本上那些仅有的知识很难解决所有的问题。 技术成长的一点思考其实编程虽然很重要，但只是IT知识中很小的一部分。要想全面提高自己还需要学习很多计算机方面的基础知识。比如操作系统、数据库、数据结构、计算机网络等知识。这些基础知识其实基本上在本科的时候都已经学习过，但是大部分人却没有使用过。这些基础知识如同编程水平一般重要，对于一个IT技术人员是不可或缺的。 对于枯燥难懂的上述理论知识，我个人更倾向于通过一些具体的IT技能去理解。比如学习操作系统就可以通过Linux，学习数据库可以通过自己搭建mysql，学习计算机网络知识可以通过wireshark抓包以及一些仿真平台去模拟。其中每一项基础知识的掌握，都需要花费大量时间，当然也很值得。如果你能精通其中任何一门基础知识，找个工作的完全没有压力。 如果你觉得掌握这些基础知识就大功告的话，那只能说naive。课程内的知识固然重要，但是作为科技界的弄潮儿，我们还需要紧跟时代发展的脚本。除了书本上常见的这些知识外，还有一些很重要基础知识，已经广泛应用于各个领域。比如 XML（包括Scheme）、Json 设计模式 Git、SVN Maven、Gradle 根据自己的发展方向还有很多知识，比如数据库工程师除了传统的关系型数据库，还得学习非关系数据库，比如后端工程师还得学习各种框架、熟练掌握多线程并发编程技术。比如偏底层的云计算工程师，还得掌握各种虚拟化技术，以及某种云计算架构。如果是前端工程师，那各种眼花缭乱的各种框架就如同家常便饭。 其实我在学习Javascript的时候，也有网上的说话说直接学习jquery就行了，何必学习Javascript。确实我必须承认jquery可以解决我的所有问题，但是jquery毕竟只是Javascript的一个库。如果放弃学习Javascript，直接学习jquery，有点舍本逐末的感觉。 当然这么多技术确实想要短时间全盘掌握，确实不太可能。但是作为初学者我们更应该打好基础，只有这样才有可能在学习新技术的时候得心应手，左右逢源。新技术并不是凭空产生，它一定是现有的技术无法解决现实生活中的某些问题，在现有技术的技术上发展而来的。其实仔细想来，IT的基础知识也不是那么多，花点时间总是可以掌握的。 写在最后的话IT技术发展这么多年后，并没有朝着简单化的方向发展。相反的是，它对于从业人员的要求越来越高，以前还分什么前端后端，现在直接就是全栈工程师，以前还分什么开发运维，现在Devops思想已经深入人心。或许留给我们初学者的只有孜孜不倦的求索，去学习掌握强势技术。另一方面，技术的学习肯定枯燥，纵然有热情和兴趣也是如此，这就需要我们沉下心来，点滴积累必然有所收获。 附关于业界技术、工具、语言的发展趋势分析以及预测报告可以参考： ThoughtWorks 学习C++可以参考如下书籍：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾Android开发]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%9B%9E%E9%A1%BEAndroid%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[前言本人在编程、软件开发方面确实是一个菜鸟，进入研究生阶段，才比较系统的学习编程（私底下）。实验室并不是做软件开发方向的，涉及到编程开发的内容相对较少。本人主要是出于兴趣，私底下学习编程。因此文中，有任何描述不专业的地方，请见谅。这完全是一篇作者闲来无事发的一篇即兴感慨。 第一次Android开发的经历这里用开发来形容好像并不准确，确切的说是尝试。大三的时候软件课程设计的需要，开发一款可以采集学校WLAN信号强度以及分布的APP。现在想想确实不难，WLAN强度以及SSID的获取很简单，而地图的功能相对来说可能难一点，但是只需要调用百度地图的SDK进行开发，应该也不是难事。相对麻烦一点，需要自己做的可能就是地图和采集到的WLAN数据进行一个整合。但是背后的逻辑显然也不是很难。 就是这样一个对于本科生来说，难度很正常的APP，让我对于Android开发有了那么一点点恐惧。说一下当时的技术背景吧，本科的我基本都在做电路相关的工作，主要是一些关于信号链的问题（装下逼），不装逼的说法是测量电路和嵌入式电路。而编程语言也只学过C，C++都不会的那种。其实C也基本属于菜鸟水平，面向对象更不知道是何物。按照现在的我来看，当时这种基础完全不适合进行Android开发。 但是由于学校课程的需要，我还是被赶鸭子上架，尝试去写这样一个Android应用。结果你们也应该猜到了，就是被搞得遍体鳞伤，体无完肤的那种。JAVA完全不会，甚至面向对象的概念都没有，怎么可能去理解人家的源码。至于配置文件，不管是布局文件还是文件也好，都是用XML写的。当时完全看不懂，只能跟着教程一步步来。就像和尚念经一样，完全是有口无心。 最后还好抱了一个大腿队友，强行带我这个坑，拿了班上第一名的好成绩。而我没有任何成就感，因为我没有贡献一行代码，完全是在打酱油。羞耻的事，说到这也差不多了 再次回眸昨天google刚上线了谷歌中国开发者的网站，这又激起了我对Android开发的兴趣。所以我特地下载了一个Android Studio，尽管我电脑上已经装了IntelliJ IDEA 。为了简单，还是选择直接安装studio。 打开界面发现还是有点似曾相识的感觉，基本配置和两年前用eclipse+ADT的配置差不多，通用设置比如字体这些调节当然和我熟悉的Intellij IDEA一样。所以在搭建环境上，速度很快 环境搭好之后，当然应该是跑一个Demo，我选择新建了一个Empty Activity，然后自己照着书增加了一个按钮，绑定了一个监听器，试了一下运用Intent在不用Activity之间切换以及传递数据。 我确实没有实现自己的任何逻辑代码，但是和两年前的自己相比，我觉得有很大不一样的是照着教程，也能很清楚的理解每一步在干什么了。不管是代码还是配置文件，我都看的一清二楚了。依旧要照着教程，我觉得只是对于Android平台还不够熟悉而言，当然也没有完全深入进去。至少理解起来，没有任何障碍 1234567891011Button button2 = (Button)findViewById(R.id.button_2);button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); Log.d("hello","hello world"); setResult(RESULT_OK, intent); finish(); &#125;&#125;); 比如上面这行代码Button button2 = (Button)findViewById(R.id.button_2);这句话利用传入R.id.button_2参数来返回得到一个相应的Button对象。其实功能根据方法的名称是可以猜出来的，当然我们也可以猜测传入的参数是int型，而得到的对象经过一次向下强制转换得到Button对象，那么我们有理由去推断，方法返回的类型应该是Button的父类View类，查一下源码发现果然是。其实类似的操作在集合中用的很多，有点像Map配合泛型使用的那种感觉。 下面的绑定监听器，自然是用了大名鼎鼎的装饰器模式，也采用匿名内部类的方式去书写，重写了Onclick()方法。这种和Swing编程中的绑定监听器几乎没有什么区别。自然得心应手. 1requestWindowFeature(Window.FEATURE_NO_TITLE); 上面的这句和swing编程this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);个人觉得也有异曲同工之妙，都是利用一个常量来设置属性参数，当然应该还有更相近的，但是暂时一下想不起来了~~ 1setContentView(R.layout.second_layout); 和this.setLayout(new GridLayout(2, 2));也差不多，只是一个传入的是常量，另一个传入的是一个对象的实例 至于Intent 12Intent intent = new Intent(MainActivity.this, SecondActivity.class);startActivityForResult(intent, 1); 个人觉得理解起来也很简单，甚至觉得比socket更简单。上面是用显式的方式去调用Intent，当然还有隐式的调用方式。 不过能够明显感受到Activity和Intent对于Android开发的重要性。像Activity的生命周期之类的，我觉得还是要深入了解的。 下面谈一下AndroidManifest.xml什么都不说，直接上代码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.hello"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" android:label="This is FirstActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.hello.ACTION_START" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".ThirdActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 大三的时候看到这个也只是一知半解，因为当时不知道XML为何物。其实我觉得要理解这个，只需要完全掌握XML的基本知识。不管这个东西是干啥的，反正就是一个XML文件，那么我就可以用XML的方式去理解它。 根节点是manifest，里面还有一些很重要的子节点像appication和activity,当然还有各种重要的属性。其实按照XML的结构去理解，我觉得还是可以理解个七八分。 当然还有layout.xml 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button_3" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 3"/&gt;&lt;/LinearLayout&gt; 除了节点就是属性，很显然属性对于刻画其中每个节点（对应于实际界面中的元素）。不管XML来描述界面是否合理，Android这种设计模式确实将界面与逻辑实现了分离，我觉得这是很重要的。 上面基本就是我花了一个小时左右时间，对于第二次接触Android的发现 结论其实写这篇随感，最终的目的就是这个结论。虽然目前我看Android依旧很肤浅，但是我觉得我有信心去掌握Android开发。在第一次和第二次接触Android的两年时间里，我觉得我并没有去接触过Android开发了，但是我觉得我的感触完全不同。只是因为我对于Android许多很基础的技术进行了储备，像JAVA SE和XML。显然我的付出还是得到了一些收获。 学习JAVA SE和XML的内容只是单纯为了学习J2EE所准备的。就像我的第一篇帖子中介绍的那样，我还在认真的学习J2EE相关的内容。第二次去接触Android开发完全是一时兴起。但是我依旧能够深切感受到技术之间是有相关性的，对于作为学生的我，我觉得最大的优势就是有时间去深入学习一门技术。我觉得这很重要，做技术的不能浅尝辄止，一定要深入。就像学习XML时，我除了理解XML的结构 ，也学习了Schema和DTD校验方式，当时还学习了如何用JAVA去解析XML文件。至于JAVA，我也尝试去深入理解面向对象的编程思想，对于JAVA中的每一个知识点，都力求彻底掌握。虽然目前学习的是J2EE，但是web开发和Android开发还是有相识的地方的，界面和背后的业务逻辑都进行了分离，只是一个界面是用了HTML+CSS这种，Android是用了XML。 最近发现阅读源码也很有意思。一方面，很多疑惑或者不解，看到源码就能秒懂，另一方面，通过阅读源码，也可以去接触大神是如何编写代码的，他们是如何实现这些功能并将API开放出来。我觉得对于提升个人编程水平也很有帮助。 当然目前来说，个人还是一个小菜鸟，还需要继续努力。暂时也不会继续深入学习Android开发了，我需要集中精力去学习J2EE的内容。就像我之前说的一样，个人认为技术不仅要有广度，更要有深度。所以我打算继续深入J2EE。希望有一天我第三次再来接触Android会有更加深刻的体会，也希望那时的我已经学成归来，可以深入Android下去。 路漫漫其修远兮，吾将上下而求索！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于openstack中Nova服务停止的解决办法]]></title>
      <url>%2F2016%2F11%2F29%2F%E5%85%B3%E4%BA%8Eopenstack%E4%B8%ADNova%E6%9C%8D%E5%8A%A1%E5%81%9C%E6%AD%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[背景Nova API服务是OpenStack控制系统的核心计算服务，我们可以通过他来管理和控制整个OpenStack系统，以及调度和管理虚拟机，也可以通过它调用系统中的其他服务 nova-compute服务负责在计算节点创建与运行虚拟机，安装步骤如下： 安装nova-compute-kvm,如下所示： 1apt-get install -y nova-compute-kvm 除此之外，nova-compute还有一堆配置文件 重启nova-compute服务 1service noca-compute restart 实际解决步骤 在compute节点上(node-25,对于我们的环境而言)，首先查看log信息，其具体位置在： 1/var/log/nova/nova-compute.log 重启libvirtd： 1service libvirtd start 重启nova-compute服务 1service nova-compute restart 友情链接重启openstack的服务命令集合 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[paramiko模块学习心得]]></title>
      <url>%2F2016%2F11%2F06%2Fparamiko%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[paramiko模块学习心得简介Paramiko is a Python (2.6+, 3.3+) implementation of the SSHv2 protocol [1], providing both client and server functionality. While it leverages a Python C extension for low level cryptography (Cryptography), Paramiko itself is a pure Python interface around SSH networking concepts. paramiko是python的一个模块，实现了SSH2协议，支持了客户端和服务器的功能。使用paramiko模块主要实现和远程服务器的文件上传、下载和执行命令。 安装1pip install paramiko windows和Ubuntu下都可以采用此方式安装 使用paramiko执行命令paramiko_client.py123456789101112131415161718192021222324252627282930313233343536373839import paramikoimport configparserclass ParamikoClient: def __init__(self, config_str): self.config = configparser.ConfigParser() self.config.read(config_str) #获取SSHClient对象 self.client = paramiko.SSHClient() #运行连接不在know_hosts文件中的主机 self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) self.sftp_client = None def connect(self): try: #注意对于配置文件中不同参数，要根据数据类型采用不同的方法取出，整型的采用getint self.client.connect(hostname=self.config.get('ssh', 'host'), port=self.config.getint('ssh', 'port') , username=self.config.get('ssh', 'username'), password=self.config.get('ssh', 'password') , timeout=self.config.getfloat('ssh', 'timeout')) except Exception as e: print(e) try: self.client.close() except: pass def run_cmd(self, cmd_str): stdin, stdout, stderr = self.client.exec_command(cmd_str) for line in stdout: print(line) #可以发现SFTPClient的建立借助于之前建立好的SSH连接，即self.client def get_sftp_client(self): if not self.sftp_client: self.sftp_client = paramiko.SFTPClient.from_transport(self.client.get_transport()) return self.sftp_client 在代码中引入configparser模块是为了解析配置文件config.ini 整体模块采用了面向对象的编程思想来用类对数据和方法进行封装。 exec_cmd.py 123456from paramiko_client import ParamikoClientif __name__ == '__main__': client = ParamikoClient('config.ini') client.connect() client.run_command('date') 为了实现代码良好的封装性，并且减少硬编码的影响，这里采用了读取配置文件的方式，加载链接所需要的必要参数，即config.iniconfig.ini 123456[ssh]host=192.168.3.137port=22username=zhangpassword=116113timeout=1.0 上传文件upload_file.py 123456789from paramiko_client import ParamikoClientclient = ParamikoClient('config.ini')client.connect()sftp_client = client.get_sftp_client()sftp_client.put('C:\\Users\\JanzenZhang\\Desktop\\network_aware.py', '/home/zhang/network_aware.py') 一定要保证在执行get_sftp_client()之前已经执行了client.connect() 下载文件download_file.py1234567from paramiko_client import ParamikoClientclient = ParamikoClient('config.ini')client.connect()sftp_client = client.get_sftp_client()sftp_client.get('/home/zhang/res.txt','C:\\Users\\JanzenZhang\\Desktop\\res.txt') 不管是上传还是下载文件，第一个参数的位置传递的都是源文件的地址。 测试环境以上代码本人均在本机以及本机上的Ubuntu 16.04虚拟主机之间测试通过 代码参考了麦子学院教程 拓展性结合python的多线程方法，可以实现多个文件的同时上传和下载，也可以同时和多个服务器进行文件传输 友情链接paramiko官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Configure Juju for OpenStack]]></title>
      <url>%2F2016%2F10%2F19%2FConfigure-Juju-for-OpenStack%2F</url>
      <content type="text"><![CDATA[前言鉴于目前网上关于Juju的资料很少，而且大部分都是介绍如何利用Juju部署Openstack环境。而这里我们将介绍如何基于本地的私有云(OpenStack)配置Juju。 Juju简介Juju 是 Canonical 公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu 服务器、OpenStack、用于裸机配置的MAAS 、以及 用于系统管理和监控的Landscape 一起组成 Ubuntu 云套件。 Juju安装官方安装教程地址 在Ubuntu下安装方式为(以Juju1.25版本为例) 12sudo add-apt-repository ppa:juju/stablesudo apt-get update &amp;&amp; sudo apt-get install juju-core 基于私有云OpenStack配置Juju生成Juju配置文件1juju generate-config 执行上述命令后，就会在路径~/.juju/下生成environments.yaml文件 下面我们要配置environments.yaml文件 在配置environments.yaml文件时，我们需要一个工具进行辅助来获得一些必要的参数，它就是Functest。 安装Functest(假定你已经安装好了docker环境) 1docker pull functest:latest 为Functest设置一些环境变量： 12env_vars=&quot;-e INSTALLER_TYPE=fuel -e INSTALLER_IP=10.20.0.2 -e DEPLOY_SCENARIO=os-nosdn-nofeature-noha&quot;result_vol=&quot;-v &#123;your_path&#125;/results:/home/opnfv/functest/results&quot; 这里your_path指定为一个已知的路径，用来存放结果 下载并在rocker容器中运行functest 1sudo docker run -id --privileged=true --name functest_demo $env_vars $results_vol opnfv/functest 进入docker容器 1sudo docker exec -ti functest_demo /bin/bash 在运行functest之前，需要准备环境变量 1functest env prepare Tips:如果在执行这条命令时，卡在了验证网络连通性的地方，很有可能是由于网卡没有配置VLAN，需要设置子网卡，并配置相应的VLAN tag。这部分应该和安装OpenStack时的网络VLAN划分保持一致。 在docker环境内，在/home/opnfv/functest/conf下找到文件openstack.creds，并用vi打开。 退出docker环境，在主机上找到路径~/.juju/下的enviroments.yaml文件，并用vi打开，主要是对openstack词条下的环境变量进行编辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type: openstack# use-floating-ip specifies whether a floating IP address is# required to give the nodes a public IP address. Some# installations assign public IP addresses by default without# requiring a floating IP address.## use-floating-ip: false# use-default-secgroup specifies whether new machine instances# should have the "default" Openstack security group assigned.## use-default-secgroup: false# network specifies the network label or uuid to bring machines up# on, in the case where multiple networks exist. It may be omitted# otherwise.## network: &lt;your network label or uuid&gt;# tools-metadata-url specifies the location of the Juju tools and# metadata. It defaults to the global public tools metadata# location https://streams.canonical.com/tools.## tools-metadata-url: https://your-tools-metadata-url# image-metadata-url specifies the location of Ubuntu cloud image# metadata. It defaults to the global public image metadata# location https://cloud-images.ubuntu.com/releases.## image-metadata-url: https://your-image-metadata-url# image-stream chooses a simplestreams stream to select OS images# from, for example daily or released images (or any other stream# available on simplestreams).## image-stream: "released"# auth-url defaults to the value of the environment variable# OS_AUTH_URL, but can be specified here.## auth-url: https://yourkeystoneurl:443/v2.0/# tenant-name holds the openstack tenant name. It defaults to the# environment variable OS_TENANT_NAME.## tenant-name: &lt;your tenant name&gt;# region holds the openstack region. It defaults to the# environment variable OS_REGION_NAME.## region: &lt;your region&gt;# The auth-mode, username and password attributes are used for# userpass authentication (the default).## auth-mode holds the authentication mode. For user-password# authentication, auth-mode should be "userpass" and username and# password should be set appropriately; they default to the# environment variables OS_USERNAME and OS_PASSWORD respectively.## auth-mode: userpass# username: &lt;your username&gt;# password: &lt;secret&gt;## For key-pair authentication, auth-mode should be "keypair" and# access-key and secret-key should be set appropriately; they# default to the environment variables OS_ACCESS_KEY and# OS_SECRET_KEY respectively.## auth-mode: keypair#access-key: &lt;secret&gt;# secret-key: &lt;secret&gt; 可以发现大部分环境变量在functest中都可以找到，下面是我们的环境变量设置情况： 其中use-floating-ip，use-default-secgroup均设置为falseagent-metadata-url，image-metadata-url的设置后面会提到，这里先不进行更改。region，auth-mode采用默认值，撤掉注释即可。network填写openstack一个私有网络即可。 关于这一部分的说明，见官网 使用Simplestreams建立私有云当使用Juju bootstrap云时，需要两种信息: The uuid of the image to use when starting new compute instances. The URL from which to download the correct version of a tools tarball. 我们可以简单的理解为上述两种信息都存储在两个json文件中。 其具体介绍可以参考官网 在生成上述两个文件之前要做一些准备工作： 上传Ubuntu 14.04LTS（Trusty）和Ubuntu 16.04LTS（Xenial）镜像到Openstack Trusty镜像下载地址 Xenial镜像下载地址 其中均选择 xxxxx-server-cloudimg-amd64-disk1.img 下载 然后就是上传到Openstack： 安装Apache服务器 1sudo apt-get install apache2 生成image json文件： 1sudo juju metadata generate-image -a amd64 -i 843bef24-8c70-40e1-a380-972717c9e4b3 -r RegionOne -s xenial -d /var/www/html/stack -u http://172.16.1.3:5000/v2.0 -e openstack 相应的命令行选项： -i 843bef24-8c70-40e1-a380-972717c9e4b3: specifies the ID of the Glance image that we just created before. -u http://172.16.1.3:5000/v2.0: specifies the Keystone URL, and should match the value from the auth-url field of our environment as specified in $HOME/.juju/environments.yaml. -e openstack: identifies the Juju environment described in $HOME/.juju/environments.yaml file. -s xenial: specifies the image series (the Ubuntu release name). -a amd64: specifies the CPU architecture. -d /var/www/html/stack: specifies the base directory where the metadata will be written to. For images, the path will be /opt/stack/images/streams/v1.. 生成tools json文件: 1juju metadata generate-tools -d /var/www/html/stack/ --stream released Tips: /var/www/html/为Apache服务器默认路径 校验生成的上述生成的文件 12juju metadata validate-imagesjuju metadata validate-tools 下载工具文件： 下载连接 并将其放到/var/www/html/stack/tools/released路径下 Tips:注意要下载和自己juju版本以及系统匹配的工具文件版本 更改上述文件的权限： 12cd /var/www/html/stacksudo chmod -R 777 ./* 最后就是bootstrap 12juju switch openstackjuju bootstrap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[没有想好标题的帖子]]></title>
      <url>%2F2016%2F09%2F28%2F%E6%B2%A1%E6%9C%89%E6%83%B3%E5%A5%BD%E6%A0%87%E9%A2%98%E7%9A%84%E5%B8%96%E5%AD%90%2F</url>
      <content type="text"><![CDATA[拖了这么久，我的blog终于搭建好了。从Pelican到Hexo，尝试了一些不同的开源工具。最后发现Hexo教程最为丰富，而且操作最为简便。虽然不是用熟悉的Python写的，但是可以让我专注于写作。 写blog最难的就是坚持把。我会争取好好坚持下来，用它记录我这三年的所学所悟所感。时光匆匆，之前生活过得太过匆忙。当我回首的时候，发现都没有记录下来，很是遗憾。现在有了这个静态博客网站就完全不一样了，我希望自己能用一种Geek的方式来记录我研究生三年的成长与蜕变 读研了很多东西都觉得不一样了，比如明白了导师为什么会叫Boss，发现实验室除了自学就是自学。没有本科的时候带你的学长了，有的只是各种催促项目进度。也发现了研究生阶段找对象将变得异常艰难。也许是身在帝都的原因把，就是感觉北邮的女生要求比华科的高。我甚至开始思考自己是否还要继续从事技术方向，为自己的出路感到迷茫。 作为一个有理想的年轻人，我相信迷茫都是暂时的。目前也基本确定了自己的技术方向，就是JAVA EE。所以blog未来可能会更多的涉及我在学习JAVA的感触与总结。选择这个方向包含自己的许多心酸与无奈。没有大数据，机器学习的背景，干不了那种高大上的热门方向。因为喜爱JAVA，又不想跟风做android方向，故选择了这个方向，深入接触之后，感觉还是很有意思的。但愿自己能继续保持一颗美好的好奇心，不灭的热情快乐地在技术道路上探索。吾生也有涯，蜕变也无涯。]]></content>
    </entry>

    
  
  
</search>
