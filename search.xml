<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[回顾Android开发]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%9B%9E%E9%A1%BEAndroid%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[前言本人在编程、软件开发方面确实是一个菜鸟，进入研究生阶段，才比较系统的学习编程（私底下）。实验室并不是做软件开发方向的，涉及到编程开发的内容相对较少。本人主要是出于兴趣，私底下学习编程。因此文中，有任何描述不专业的地方，请见谅。这完全是一篇作者闲来无事发的一篇即兴感慨。 第一次Android开发的经历这里用开发来形容好像并不准确，确切的说是尝试。当时是在大三的时候软件课程设计的需要，要求开发一款可以采集学校WLAN信号强度以及分布的APP。现在想想确实不难，WLAN强度以及SSID的获取很简单，而地图的功能相对来说可能难一点，但是只需要调用百度地图的SDK进行开发，应该也不是难事。相对麻烦一点，需要自己做的可能就是地图和采集到的WLAN数据进行一个整合。但是背后的逻辑显然也不是很难。 就是这样一个对于本科生来说，难度很正常的APP，让我对于Android开发有了那么一点点恐惧。说一下当时的技术背景吧，本科的我基本都在做电路相关的工作，主要是一些关于信号链的问题（装下逼），确切的说是测量电路和嵌入式电路。而编程语言也只学过C，C++都不会的那种。其实C也基本属于菜鸟水平，面向对象更不知道是何物。按照现在的我来看，当时这种基础完全不适合进行Android开发。 但是由于学校课程的需要，我还是被赶鸭子上架，尝试去写这样一个Android应用。结果你们也应该猜到了，就是被搞得遍体鳞伤，体无完肤的那种。JAVA完全不会，甚至面向对象的概念都没有，怎么可能去理解人家的源码。至于配置文件，不管是布局文件还是文件也好，都是用XML写的。当时完全看不懂，只能跟着教程一步步来。就像和尚念经一样，完全是有口无心。 最后还好抱了一个大腿队友，强行带我这个坑，拿了班上第一名的好成绩。而我没有任何成就感，因为我没有贡献一行代码，完全是在打酱油。羞耻的事，说到这也差不多了 再次回眸昨天google刚上线了谷歌中国开发者的网站，这又激起了我对Android开发的兴趣。所以我特地下载了一个Android Studio，尽管我电脑上已经装了IntelliJ IDEA 。为了简单，还是选择直接安装studio。 打开界面发现还是有点似曾相识的感觉，基本配置和两年前用eclipse+ADT的配置差不多，基本设置比如字体这些调节当然和我熟悉的Intellij IDEA一样。所以在搭建环境上，速度很快 环境搭好之后，当然应该是跑一个Demo，我选择新建了一个Empty Activity，然后自己照着书增加了一个按钮，绑定了一个监听器，试了一下运用Intent在不用Activity之间切换以及传递数据。 我确实没有实现自己的任何逻辑代码，但是和两年前的自己相比，我觉得有很大不一样的是照着教程，也能很清楚的理解每一步在干什么了。不管是代码还是配置文件，我都看的一清二楚了。依旧要照着教程，我觉得只是对于Android平台还不够熟悉而言，当然也没有完全深入进去。至少理解起来，没有任何障碍 1234567891011Button button2 = (Button)findViewById(R.id.button_2);button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;); Log.d(&quot;hello&quot;,&quot;hello world&quot;); setResult(RESULT_OK, intent); finish(); &#125;&#125;); 比如上面这行代码Button button2 = (Button)findViewById(R.id.button_2);这句话利用传入R.id.button_2参数来返回得到一个相应的Button对象。其实功能根据方法的名称是可以猜出来的，当然我们也可以继续传入的参数是int型，而得到的对象经过一次向下强制转换得到Button对象，那么我们有理由去推断，方法返回的类型应该是Button的父类View类，查一下源码发现果然是。其实类似的操作在集合中用的很多，有点像Map配合泛型使用的那种感觉。 下面的绑定监听器，自然是用了大名鼎鼎的装饰器模式，也采用内部类的方式去书写，重写了Onclick()方法。这种和Swing编程中的绑定监听器几乎没有什么区别。自然得心应手. 1requestWindowFeature(Window.FEATURE_NO_TITLE); 上面的这句和swing编程this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);个人觉得也有异曲同工之妙，都是利用一个常量来设置属性参数，当然应该还有更相近的，但是暂时一下想不起来了~~ 1setContentView(R.layout.second_layout); 和this.setLayout(new GridLayout(2, 2));也差不多，只是一个传入的是常量，另一个穿入的是一个对象的实例 至于Intent 12Intent intent = new Intent(MainActivity.this, SecondActivity.class);startActivityForResult(intent, 1); 个人觉得理解起来也很简单，甚至觉得比socket更简单。上面是用显式的方式去调用Intent，当然还有隐式的调用方式。 不过能够明显感受到Activity和Intent对于Android开发的重要性。像Activity的生命周期之类的，我觉得还是要深入了解的。 下面谈一下AndroidManifest.xml什么都不说，直接上代码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.hello&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;This is FirstActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.hello.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.ThirdActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 大三的时候看到这个也只是一知半解，因为当时不知道XML为何物。其实我觉得要理解这个，只需要完全掌握XML的基本知识。不管这个东西是干啥的，反正就是一个XML文件，那么我就可以用XML的方式去理解它。 根节点是manifest，里面还有一些很重要的子节点像appication和activity,当然还有各种重要的属性。其实按照XML的结构去理解，我觉得还是可以理解个七八分。 当然还有layout.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/button_3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 3&quot;/&gt;&lt;/LinearLayout&gt; 除了节点就是属性，很显然属性对于刻画其中每个节点（对于实际画面中的元素）。不管XML来描述界面是否合理，Android这种设计模式确实将界面与逻辑实现了分离，我觉得这是很重要的。 上面基本就是我花了一个小时左右时间，对于第二次接触Android的发现 结论其实写这篇随感，最终的目的就是这个结论。虽然目前看Android依旧很肤浅，但是我觉得我有信心去掌握Android开发。在第一次和第二次接触Android的两年时间里，我觉得我并没有去接触过Android开发了，但是我觉得我的感触完全不同。只是因为我对于Android许多很基础的技术进行了储备，像JAVA SE和XML。显然我的付出还是得到了一些收获。 学习JAVA SE和XML的内容只是单纯为了学习J2EE所准备的。就像我的第一篇帖子中介绍的那样，我还在认真的学习J2EE相关的内容。第二次去接触Android开发完全是一时兴起。但是我依旧能够深切感受到技术之间是有相关性的，对于作为学生的我，我觉得最大的优势就是有时间去深入学习一门技术。我觉得这很重要，做技术的不能浅尝辄止，一定要深入。就像学习XML时，我除了理解XML的结构 ，也学习了Schema和DTD校验方式，当时还学习了如何用JAVA去解析XML文件。至于JAVA，我也尝试去深入理解面向对象的编程思想，对于JAVA中的每一个知识点，都力求彻底掌握。虽然目前学习的J2EE，但是web开发和Android开发还是有相识的地方的，界面和背后的业务逻辑都进行了分离，只是一个界面是用了HTML+CSS这种，Android是用了XML。 最近发现阅读源码也很有意思。一方面，很多疑惑或者不解，看到源码就能秒懂，另一方面，通过阅读源码，也可以去接触大神是如何编写代码的，他们是如何实现这些功能并将API开放出来。我觉得对于提升个人编程水平也很有帮助。 当然目前来说，个人还是一个小菜鸟，还需要继续努力。暂时也不会继续深入学习Android开发了，我需要集中精力去学习J2EE的内容。就像我之前说的一样，个人认为技术不仅要有广度，更要有深度。所以我打算继续深入J2EE。希望有一天我第三次再来接触Android会有更加深刻的体会，也希望那时的我已经学成归来，可以深入Android下去。 路漫漫其修远兮，吾将上下而求索！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于openstack中Nova服务停止的解决办法]]></title>
      <url>%2F2016%2F11%2F29%2F%E5%85%B3%E4%BA%8Eopenstack%E4%B8%ADNova%E6%9C%8D%E5%8A%A1%E5%81%9C%E6%AD%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[背景Nova API服务是OpenStack控制系统的核心计算服务，我们可以通过他来管理和控制整个OpenStack系统，以及调度和管理虚拟机，也可以通过它调用系统中的其他服务 nova-compute服务负责在计算节点创建与运行虚拟机，安装步骤如下： 安装nova-compute-kvm,如下所示： 1apt-get install -y nova-compute-kvm 除此之外，nova-compute还有一堆配置文件 重启nova-compute服务 1service noca-compute restart 实际解决步骤 在compute节点上(node-25,对于我们的环境而言)，首先查看log信息，其具体位置在： 1/var/log/nova/nova-compute.log 重启libvirtd： 1service libvirtd start 重启nova-compute服务 1service nova-compute restart 友情链接重启openstack的服务命令集合 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[paramiko模块学习心得]]></title>
      <url>%2F2016%2F11%2F06%2Fparamiko%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[paramiko模块学习心得简介Paramiko is a Python (2.6+, 3.3+) implementation of the SSHv2 protocol [1], providing both client and server functionality. While it leverages a Python C extension for low level cryptography (Cryptography), Paramiko itself is a pure Python interface around SSH networking concepts. paramiko是python的一个模块，实现了SSH2协议，支持了客户端和服务器的功能。使用paramiko模块主要实现和远程服务器的文件上传、下载和执行命令。 安装1pip install paramiko windows和Ubuntu下都可以采用此方式安装 使用paramiko执行命令paramiko_client.py123456789101112131415161718192021222324252627282930313233343536373839import paramikoimport configparserclass ParamikoClient: def __init__(self, config_str): self.config = configparser.ConfigParser() self.config.read(config_str) #获取SSHClient对象 self.client = paramiko.SSHClient() #运行连接不在know_hosts文件中的主机 self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) self.sftp_client = None def connect(self): try: #注意对于配置文件中不同参数，要根据数据类型采用不同的方法取出，整型的采用getint self.client.connect(hostname=self.config.get(&apos;ssh&apos;, &apos;host&apos;), port=self.config.getint(&apos;ssh&apos;, &apos;port&apos;) , username=self.config.get(&apos;ssh&apos;, &apos;username&apos;), password=self.config.get(&apos;ssh&apos;, &apos;password&apos;) , timeout=self.config.getfloat(&apos;ssh&apos;, &apos;timeout&apos;)) except Exception as e: print(e) try: self.client.close() except: pass def run_cmd(self, cmd_str): stdin, stdout, stderr = self.client.exec_command(cmd_str) for line in stdout: print(line) #可以发现SFTPClient的建立借助于之前建立好的SSH连接，即self.client def get_sftp_client(self): if not self.sftp_client: self.sftp_client = paramiko.SFTPClient.from_transport(self.client.get_transport()) return self.sftp_client 在代码中引入configparser模块是为了解析配置文件config.ini 整体模块采用了面向对象的编程思想来用类对数据和方法进行封装。 exec_cmd.py 123456from paramiko_client import ParamikoClientif __name__ == &apos;__main__&apos;: client = ParamikoClient(&apos;config.ini&apos;) client.connect() client.run_command(&apos;date&apos;) 为了实现代码良好的封装性，并且减少硬编码的影响，这里采用了读取配置文件的方式，加载链接所需要的必要参数，即config.iniconfig.ini 123456[ssh]host=192.168.3.137port=22username=zhangpassword=116113timeout=1.0 上传文件upload_file.py 123456789from paramiko_client import ParamikoClientclient = ParamikoClient(&apos;config.ini&apos;)client.connect()sftp_client = client.get_sftp_client()sftp_client.put(&apos;C:\\Users\\JanzenZhang\\Desktop\\network_aware.py&apos;, &apos;/home/zhang/network_aware.py&apos;) 一定要保证在执行get_sftp_client()之前已经执行了client.connect() 下载文件download_file.py1234567from paramiko_client import ParamikoClientclient = ParamikoClient(&apos;config.ini&apos;)client.connect()sftp_client = client.get_sftp_client()sftp_client.get(&apos;/home/zhang/res.txt&apos;,&apos;C:\\Users\\JanzenZhang\\Desktop\\res.txt&apos;) 不管是上传还是下载文件，第一个参数的位置传递的都是源文件的地址。 测试环境以上代码本人均在本机以及本机上的Ubuntu 16.04虚拟主机之间测试通过 代码参考了麦子学院教程 拓展性结合python的多线程方法，可以实现多个文件的同时上传和下载，也可以同时和多个服务器进行文件传输 友情链接paramiko官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Configure Juju for OpenStack]]></title>
      <url>%2F2016%2F10%2F19%2FConfigure-Juju-for-OpenStack%2F</url>
      <content type="text"><![CDATA[前言鉴于目前网上关于Juju的资料很少，而且大部分都是介绍如何利用Juju部署Openstack环境。而这里我们将介绍如何基于本地的私有云(OpenStack)配置Juju。 Juju简介Juju 是 Canonical 公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu 服务器、OpenStack、用于裸机配置的MAAS 、以及 用于系统管理和监控的Landscape 一起组成 Ubuntu 云套件。 Juju安装官方安装教程地址 在Ubuntu下安装方式为(以Juju1.25版本为例) 12sudo add-apt-repository ppa:juju/stablesudo apt-get update &amp;&amp; sudo apt-get install juju-core 基于私有云OpenStack配置Juju生成Juju配置文件1juju generate-config 执行上述命令后，就会在路径~/.juju/下生成environments.yaml文件 下面我们要配置environments.yaml文件 在配置environments.yaml文件时，我们需要一个工具进行辅助来获得一些必要的参数，它就是Functest。 安装Functest(假定你已经安装好了docker环境) 1docker pull functest:latest 为Functest设置一些环境变量： 12env_vars=&quot;-e INSTALLER_TYPE=fuel -e INSTALLER_IP=10.20.0.2 -e DEPLOY_SCENARIO=os-nosdn-nofeature-noha&quot;result_vol=&quot;-v &#123;your_path&#125;/results:/home/opnfv/functest/results&quot; 这里your_path指定为一个已知的路径，用来存放结果 下载并在rocker容器中运行functest 1sudo docker run -id --privileged=true --name functest_demo $env_vars $results_vol opnfv/functest 进入docker容器 1sudo docker exec -ti functest_demo /bin/bash 在运行functest之前，需要准备环境变量 1functest env prepare Tips:如果在执行这条命令时，卡在了验证网络连通性的地方，很有可能是由于网卡没有配置VLAN，需要设置子网卡，并配置相应的VLAN tag。这部分应该和安装OpenStack时的网络VLAN划分保持一致。 在docker环境内，在/home/opnfv/functest/conf下找到文件openstack.creds，并用vi打开。 退出docker环境，在主机上找到路径~/.juju/下的enviroments.yaml文件，并用vi打开，主要是对openstack词条下的环境变量进行编辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type: openstack# use-floating-ip specifies whether a floating IP address is# required to give the nodes a public IP address. Some# installations assign public IP addresses by default without# requiring a floating IP address.## use-floating-ip: false# use-default-secgroup specifies whether new machine instances# should have the &quot;default&quot; Openstack security group assigned.## use-default-secgroup: false# network specifies the network label or uuid to bring machines up# on, in the case where multiple networks exist. It may be omitted# otherwise.## network: &lt;your network label or uuid&gt;# tools-metadata-url specifies the location of the Juju tools and# metadata. It defaults to the global public tools metadata# location https://streams.canonical.com/tools.## tools-metadata-url: https://your-tools-metadata-url# image-metadata-url specifies the location of Ubuntu cloud image# metadata. It defaults to the global public image metadata# location https://cloud-images.ubuntu.com/releases.## image-metadata-url: https://your-image-metadata-url# image-stream chooses a simplestreams stream to select OS images# from, for example daily or released images (or any other stream# available on simplestreams).## image-stream: &quot;released&quot;# auth-url defaults to the value of the environment variable# OS_AUTH_URL, but can be specified here.## auth-url: https://yourkeystoneurl:443/v2.0/# tenant-name holds the openstack tenant name. It defaults to the# environment variable OS_TENANT_NAME.## tenant-name: &lt;your tenant name&gt;# region holds the openstack region. It defaults to the# environment variable OS_REGION_NAME.## region: &lt;your region&gt;# The auth-mode, username and password attributes are used for# userpass authentication (the default).## auth-mode holds the authentication mode. For user-password# authentication, auth-mode should be &quot;userpass&quot; and username and# password should be set appropriately; they default to the# environment variables OS_USERNAME and OS_PASSWORD respectively.## auth-mode: userpass# username: &lt;your username&gt;# password: &lt;secret&gt;## For key-pair authentication, auth-mode should be &quot;keypair&quot; and# access-key and secret-key should be set appropriately; they# default to the environment variables OS_ACCESS_KEY and# OS_SECRET_KEY respectively.## auth-mode: keypair#access-key: &lt;secret&gt;# secret-key: &lt;secret&gt; 可以发现大部分环境变量在functest中都可以找到，下面是我们的环境变量设置情况： 其中use-floating-ip，use-default-secgroup均设置为falseagent-metadata-url，image-metadata-url的设置后面会提到，这里先不进行更改。region，auth-mode采用默认值，撤掉注释即可。network填写openstack一个私有网络即可。 关于这一部分的说明，见官网 使用Simplestreams建立私有云当使用Juju bootstrap云时，需要两种信息: The uuid of the image to use when starting new compute instances. The URL from which to download the correct version of a tools tarball. 我们可以简单的理解为上述两种信息都存储在两个json文件中。 其具体介绍可以参考官网 在生成上述两个文件之前要做一些准备工作： 上传Ubuntu 14.04LTS（Trusty）和Ubuntu 16.04LTS（Xenial）镜像到Openstack Trusty镜像下载地址 Xenial镜像下载地址 其中均选择 xxxxx-server-cloudimg-amd64-disk1.img 下载 然后就是上传到Openstack： 安装Apache服务器 1sudo apt-get install apache2 生成image json文件： 1sudo juju metadata generate-image -a amd64 -i 843bef24-8c70-40e1-a380-972717c9e4b3 -r RegionOne -s xenial -d /var/www/html/stack -u http://172.16.1.3:5000/v2.0 -e openstack 相应的命令行选项： -i 843bef24-8c70-40e1-a380-972717c9e4b3: specifies the ID of the Glance image that we just created before. -u http://172.16.1.3:5000/v2.0: specifies the Keystone URL, and should match the value from the auth-url field of our environment as specified in $HOME/.juju/environments.yaml. -e openstack: identifies the Juju environment described in $HOME/.juju/environments.yaml file. -s xenial: specifies the image series (the Ubuntu release name). -a amd64: specifies the CPU architecture. -d /var/www/html/stack: specifies the base directory where the metadata will be written to. For images, the path will be /opt/stack/images/streams/v1.. 生成tools json文件: 1juju metadata generate-tools -d /var/www/html/stack/ --stream released Tips: /var/www/html/为Apache服务器默认路径 校验生成的上述生成的文件 12juju metadata validate-imagesjuju metadata validate-tools 下载工具文件： 下载连接 并将其放到/var/www/html/stack/tools/released路径下 Tips:注意要下载和自己juju版本以及系统匹配的工具文件版本 更改上述文件的权限： 12cd /var/www/html/stacksudo chmod -R 777 ./* 最后就是bootstrap 12juju switch openstackjuju bootstrap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[没有想好标题的帖子]]></title>
      <url>%2F2016%2F09%2F28%2F%E6%B2%A1%E6%9C%89%E6%83%B3%E5%A5%BD%E6%A0%87%E9%A2%98%E7%9A%84%E5%B8%96%E5%AD%90%2F</url>
      <content type="text"><![CDATA[拖了这么久，我的blog终于搭建好了。从Pelican到Hexo，尝试了一些不同的开源工具。最后发现Hexo教程最为丰富，而且操作最为简便。虽然不是用熟悉的Python写的，但是可以让我专注于写作。 写blog最难的就是坚持把。我会争取好好坚持下来，用它记录我这三年的所学所悟所感。时光匆匆，之前生活过得太过匆忙。当我回首的时候，发现都没有记录下来，很是遗憾。现在有了这个静态博客网站就完全不一样了，我希望自己能用一种Geek的方式来记录我研究生三年的成长与蜕变 读研了很多东西都觉得不一样了，比如明白了导师为什么会叫Boss，发现实验室除了自学就是自学。没有本科的时候带你的学长了，有的只是各种催促项目进度。也发现了研究生阶段找对象将变得异常艰难。也许是身在帝都的原因把，就是感觉北邮的女生要求比华科的高。我甚至开始思考自己是否还要继续从事技术方向，为自己的出路感到迷茫。 作为一个有理想的年轻人，我相信迷茫都是暂时的。目前也基本确定了自己的技术方向，就是JAVA EE。所以blog未来可能会更多的涉及我在学习JAVA的感触与总结。选择这个方向包含自己的许多心酸与无奈。没有大数据，机器学习的背景，干不了那种高大上的热门方向。因为喜爱JAVA，又不想跟风做android方向，故选择了这个方向，深入接触之后，感觉还是很有意思的。但愿自己能继续保持一颗美好的好奇心，不灭的热情快乐地在技术道路上探索。吾生也有涯，蜕变也无涯。]]></content>
    </entry>

    
  
  
</search>
